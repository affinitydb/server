<head>
  <script src='js/jquery.js' type='text/javascript'></script>
  <script src='js/snippets_to_console.js' type='text/javascript'></script>
  <link href='css/mvdoc.css' rel='stylesheet' type='text/css' />
</head>
<div id='mvtocbar'>
  <select id='mvtoclist'>
    <option value='features'>features</option>
    <option value='intro'>intro</option>
    <option value='mvEngine getting started'>mvEngine getting started</option>
    <option value='mvSQL getting started'>mvSQL getting started</option>
    <option value='mvSQL reference'>mvSQL reference</option>
    <option value='mvStore FAQ' SELECTED>mvStore FAQ</option>
    <option value='mvStore build from source'>mvStore build from source</option>
    <option value='mvStore cpp'>mvStore cpp</option>
    <option value='mvStore getting started'>mvStore getting started</option>
    <option value='mvStore js'>mvStore js</option>
    <option value='mvStore protobuf'>mvStore protobuf</option>
    <option value='mvStore server'>mvStore server</option>
    <option value='strengths'>strengths</option>
    <option value='terminology'>terminology</option>
  </select>
</div
<div id="what-is-mvstore"
><h1
  >What is mvStore?</h1
  ><p
  >mvStore is a new database kernel with features that borrow (we hope the best) aspects from RDBMS, OODBMS, document databases, graph databases, and RDF and XML stores. In academic terms, it is a hybrid between value-oriented databases (that distinguish entities primarily by their values [e.g. primary keys of relational systems]) and ID-based object-oriented databases.</p
  ><p
  >Unlike relational databases, mvStore is schema-less (no tables), yet provides a rich native <a href="./terminology.html#essential-concepts-data-model"
    >data model</a
    > including objects with fields of various native datatypes, ordered <a href="./terminology.html#collection"
    >collections</a
    > (for modeling XML-like list structures) and <a href="./terminology.html#pin-reference"
    >references</a
    > (for modeling relationships between objects). Objects are self-describing (every field is labeled with a URI) and freely extensible (different objects can have different fields). Schema or organization (<a href="./terminology.html#class"
    >classes</a
    >) can be overlaid on the data, without any change to the data.</p
  ><p
  >mvStore provides built-in <a href="./terminology.html#index"
    >indexing</a
    > (both structured and full-text) and query processing. However, unlike relational systems, mvStore does this using dynamic <a href="./terminology.html#class"
    >classification</a
    >. The result is that mvStore objects do not need to be declared as belonging to any specific class (or table) when they are created. Instead, objects can be stored first, and then dynamically classified into independently defined classes. Membership in these classes may change as the objects change, and as new applications with new classes begin operating in the database.</p
  ><p
  >The current C++ implementation of mvStore runs in a small-footprint, multithreaded process on windows or linux systems. Data is persisted in the file system. There is support for ACID transactions with isolation and crash recovery.</p
  ><p
  >mvStore has a native <a href="./terminology.html#c-interface"
    >C++ interface</a
    >, as well as a remoteable interface operating through <a href="./terminology.html#protocol-buffer"
    >protobuf</a
    >-encoded request/response streams. Queries can be passed to the database via <a href="./terminology.html#mvsql"
    >mvSQL</a
    >, a SQL-like query language.</p
  ><p
  >mvStore can also operate as a MySQL storage engine via <a href="./terminology.html#mvengine"
    >mvEngine</a
    >, which maps between the native mvStore data model and the MySQL relational data model.</p
  ><p
  >Please refer to the <a href="./strengths.html"
    >strengths</a
    > page, for more information on the basic tenets of mvStore.</p
  ></div
><div id="faq"
><h1
  >FAQ</h1
  ><p
  >This section will provide answers to frequently-asked questions.</p
  ></div
>
