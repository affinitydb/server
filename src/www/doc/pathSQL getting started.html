<head>
  <script src='js/jquery.js' type='text/javascript'></script>
  <script src='js/snippets_to_console.js' type='text/javascript'></script>
  <link href='css/mvdoc.css' rel='stylesheet' type='text/css' />
</head>
<div id='mvtocbar'>
  <select id='mvtoclist'>
    <option value='features'>features</option>
    <option value='intro'>intro</option>
    <option value='mvStore FAQ'>mvStore FAQ</option>
    <option value='mvStore cpp'>mvStore cpp</option>
    <option value='mvStore getting started'>mvStore getting started</option>
    <option value='mvStore js'>mvStore js</option>
    <option value='mvStore protobuf'>mvStore protobuf</option>
    <option value='mvStore server'>mvStore server</option>
    <option value='pathSQL getting started' SELECTED>pathSQL getting started</option>
    <option value='pathSQL reference'>pathSQL reference</option>
    <option value='release notes'>release notes</option>
    <option value='strengths'>strengths</option>
    <option value='terminology'>terminology</option>
  </select>
</div>
<div id="getting-started-with-pathsql"
><h1
  >Getting Started with pathSQL</h1
  ><p
  >pathSQL is the name of a dialect of SQL defined for mvStore. Although the <a href="./terminology.html#essential-concepts-data-model"
    >mvStore data model</a
    > is different from relational databases, pathSQL is designed to be as close to SQL as possible. This document shows <strong
    >how to</strong
    > insert, update, query and index data (<a href="./terminology.html#pin"
    >PINs</a
    >).</p
  ><p
  >For a more systematic survey of pathSQL and its commands, please visit the <a href="./pathSQL%20reference.html"
    >reference</a
    >.</p
  >To execute an example on this page, either click on it, or click on the purple button in front of it.<div class="pathsql_button_fake">v</div>  
<p
  >To setup your own runtime environment, please visit this <a href="./mvStore%20getting%20started.html"
    >link</a
    >.</p
  ><div id="how-to-insert-data"
  ><h2
    >How to insert data</h2
    ><p
    >There is no concept of table in mvStore: all data are inserted in global scope. Two styles can be used to perform <a href="./terminology.html#pin"
      >PIN</a
      > inserts:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >SQL-like syntax:</li
      ></ol
    ><p
    ><code class='pathsql_snippet'>INSERT (property1, property2) VALUES ('value1','value2');</code></p
    ><ol start="2" style="list-style-type: decimal;"
    ><li
      >mvStore-specific syntax:</li
      ></ol
    ><p
    ><code class='pathsql_snippet'>INSERT property1 ='value1', property2 ='value2';</code></p
    ><p
    >Different <a href="./pathSQL%20reference.html#data-types"
      >data types</a
      > may have different input formats, e.g.</p
    ><p
    ><code class='pathsql_snippet'>INSERT prop_string ='string', prop_binary_string =X'DEF5', prop_url=U'http://test/', prop_int=128, prop_float=3.40282f, prop_double=3.40282, prop_bool=true, prop_datatime=TIMESTAMP '2010-12-31 23:59:59', prop_internal=INTERVAL '-12:00:00', prop_collection={1,2,4};</code></p
    ><p
    >More examples:</p
    ><p
    ><code class='pathsql_snippet'>INSERT name='Jurgen', bornin='South Africa', email='jsmith@acme.org', livesin='Boston', age=22;</code></p
    ><p
    ><code class='pathsql_snippet'>INSERT (name, bornin, email, livesin, age) VALUES ('Sonny', 'USA', 'sbrown@acme.org', 'Boston', 45);</code></p
    ></div
  ><div id="how-to-update-or-delete-data"
  ><h2
    >How to update or delete data</h2
    ><p
    ><code class='pathsql_snippet'>UPDATE ADD livesin='Cambridge' WHERE name='Sonny';</code></p
    ><p
    ><code class='pathsql_snippet'>UPDATE SET livesin[1]='USA' WHERE name='Sonny';</code></p
    ><p
    ><code class='pathsql_snippet'>UPDATE SET age=(SELECT AVG(age) FROM *) WHERE name='Sonny';</code></p
    ><p
    ><code class='pathsql_inert'>UPDATE @50004 ADD school='MIT';</code></p
    ><p
    ><code class='pathsql_inert'>DELETE @50004;</code></p
    ></div
  ><div id="how-to-classify-data"
  ><h2
    >How to classify data</h2
    ><p
    >All data are inserted in global scope, but applications can freely define specialized access paths for their data (before or after the data is inserted), by creating <a href="./terminology.html#class"
      >classes</a
      >. Here's an example:</p
    ><p
    ><code class='pathsql_snippet'>CREATE CLASS class1 AS SELECT * WHERE bornin IS NOT NULL;</code></p
    ><p
    ><code class='pathsql_snippet'>CREATE CLASS class2 AS SELECT * WHERE name IN :0;</code></p
    ></div
  ><div id="how-to-query"
  ><h2
    >How to query</h2
    ><p
    >Most of the querying syntax in mvStore is compatible with standard SQL: expressions, function calls, WHERE, ORDER BY, UNION, INTERSECT, EXCEPT etc. Here's an example:</p
    ><p
    ><code class='pathsql_snippet'>SELECT * FROM class1 WHERE LENGTH(bornin) &gt; 5 ORDER BY livesin DESC NULLS FIRST;</code></p
    ><p
    >Other examples:</p
    ><p
    ><code class='pathsql_snippet'>SELECT name, email WHERE EXISTS(livesin);</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT WHERE livesin='Boston' ORDER BY name ASC;</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT * MATCH AGAINST('Boston');</code></p
    ></div
  ><div id="how-to-use-joins"
  ><h2
    >How to use joins</h2
    ><p
    >mvStore returns immutable PIN collections as query results. Here's an example:</p
    ><p
    ><code class='pathsql_snippet'>SELECT * FROM class1 AS c1 JOIN class2('Jurgen') AS c2 ON (c1.name = c2.name);</code></p
    ><p
    >mvStore supports every kind of JOIN (LEFT/RIGHT/FULL/CROSS JOIN), except the Natural JOIN.</p
    ></div
  ><div id="how-to-use-references"
  ><h2
    >How to use <a href="./terminology.html#pin-reference"
      >references</a
      ></h2
    ><p
    >Relational databases use foreign keys to establish relationships between tables. mvStore offers a powerful alternative with <a href="./terminology.html#pin-reference"
      >references</a
      > (similar to object-oriented databases):</p
    ><p
    ><code class='pathsql_snippet'> INSERT (name, bornin, email, livesin, age, friends, photos) VALUES ('Fred', 'France', 'fred@acme.org', 'Chicago', 27, {(INSERT (name, bornin, email, livesin, age, photos) VALUES ('Tony', 'Hungary', 'tony@acme.org', 'Calgary', 76, {(INSERT photo_name='blue.jpg'), (INSERT photo_name='red.jpg'), (INSERT photo_name='green.jpg')})), (INSERT (name, bornin, email, livesin, age, photos) VALUES ('Peter', 'Mexico', 'peter@acme.org', 'Mexico', 45, {(INSERT photo_name='rose.jpg'), (INSERT photo_name='petunia.jpg'), (INSERT photo_name='orchid.jpg')}))}, {(INSERT photo_name='Greece.jpg'), (INSERT photo_name='Germany.jpg'), (INSERT photo_name='USA.jpg'), (INSERT photo_name='France.jpg')});</code></p
    ><p
    ><code class='pathsql_snippet'>UPDATE ADD friends=(SELECT mv:pinID WHERE name='Fred') WHERE name='Jurgen';</code></p
    ><p
    ><code class='pathsql_snippet'>UPDATE ADD friends=(SELECT friends[0] WHERE name='Jurgen') WHERE name='Sonny';</code></p
    ><p
    ><code class='pathsql_inert'>INSERT mypinref=@50004;</code></p
    ><p
    ><code class='pathsql_inert'>INSERT mypropref=@50004.friends;</code></p
    ><p
    >To leverage this information while querying, pathSQL offers the following syntax (path expression):</p
    ><p
    ><code class='pathsql_snippet'>SELECT name, email, bornin FROM class1.friends[BEGINS(livesin, 'C')].friends;</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT bornin FROM class2('Jurgen').friends{*}[BEGINS(livesin, 'C')];</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT age FROM class2('Jurgen').friends{+}[age &gt; 30];</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT DISTINCT FROM class1.friends{*}.photos;</code></p
    ><p
    >Note that in the current release, path expressions are only available in the FROM clause.</p
    ></div
  ><div id="how-to-use-collections"
  ><h2
    >How to use <a href="./terminology.html#collection"
      >collections</a
      ></h2
    ><div id="add-elements-to-a-collection"
    ><h3
      >1. Add elements to a <a href="./terminology.html#collection"
	>collection</a
	></h3
      ><div id="insert-a-pin-with-a-collection-property:"
      ><h4
	>1.1 Insert a PIN with a collection property:</h4
	><p
	><code class='pathsql_snippet'>INSERT (prop1, prop2) VALUES ({1, 'inserted', '3'}, 2);</code></p
	></div
      ><div id="update-a-property-in-a-collection"
      ><h4
	>1.2 Update a property in a collection</h4
	><p
	>Using &quot;UPDATE ... SET ...&quot;, we can replace a property with a whole collection directly:</p
	><p
	><code class='pathsql_inert'>UPDATE @50001 SET prop3={3, 'update set'};</code></p
	><p
	>Using &quot;UPDATE ... ADD ...&quot;, we can convert a property from a scalar value to a collection:</p
	><p
	><code class='pathsql_inert'>UPDATE @50001 ADD prop2='update add';</code></p
	></div
      ></div
    ><div id="delete-an-element-from-a-collection"
    ><h3
      >2. Delete an element from a collection</h3
      ><p
      ><code class='pathsql_inert'>UPDATE @50001 DELETE prop1[2];</code></p
      ></div
    ><div id="query-on-collections"
    ><h3
      >3. Query on collections</h3
      ><p
      >Here are a few examples of queries that can be run against the PIN created in section 1.1:</p
      ><blockquote
      ><ol style="list-style-type: decimal;"
	><li
	  >SELECT * WHERE 1 IN prop1;<br
	     /></li
	  ><li
	  >SELECT * WHERE {1,2} IN prop1;<br
	     /></li
	  ><li
	  >SELECT * WHERE 1 = prop1; -- equivalent to example 1.</li
	  ><li
	  >SELECT * WHERE {1,2} = prop1; -- equivalent to example 2.</li
	  ></ol
	></blockquote
      ></div
    ></div
  ><div id="how-to-index-properties"
  ><h2
    >How to index properties</h2
    ><p
    >mvStore does not support the &quot;CREATE INDEX&quot; statement. However, it proposes a somewhat similar statement: &quot;CREATE CLASS family&quot;. Here's an example:</p
    ><p
    ><code class='pathsql_snippet'>CREATE CLASS clsfml AS SELECT * WHERE age IN :0(int, desc, nulls first) AND name IN :1;</code></p
    ><p
    >This class <a href="./terminology.html#family"
      >family</a
      > will create an <a href="./terminology.html#index"
      >index</a
      > on prop1 and prop2. The prop1 will be sorted in descending order, and will order nulls first. When parameters are passed, the class family behaves like a CLASS. For example:</p
    ><p
    ><code class='pathsql_snippet'>SELECT * FROM clsfml(27, 'Fred');</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT * FROM clsfml([50, 10], ['A', 'H']);</code></p
    ><p
    ><code class='pathsql_snippet'>SELECT * FROM clsfml;</code></p
    ><p
    ><code class='pathsql_inert'>SELECT * FROM clsfml(*, 'Fred');</code></p
    ><p
    ><code class='pathsql_inert'>SELECT * FROM clsfml(27, *);</code></p
    ></div
  ></div
>
