<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' />
  <script src='js/jquery.js' type='text/javascript'></script>
  <script src='js/afysnippets.js' type='text/javascript'></script>
  <link href='css/afydoc.css' rel='stylesheet' type='text/css' media='screen and (min-device-width: 600px)' />
  <link href='../m/doc/css/afydoc.css' rel='stylesheet' type='text/css' media='screen and (max-device-width: 599px)' />
  <meta http-equiv='content-type' content='text/html; charset=utf-8'></meta>
</head>
<div id='width_constraint' class='horizontally_centered'>
<div id='generic_header'>
<img src='images/logo_small.png' id='gh_logo_img'></img>
<div id='afytocbar'>
  <select id='afytoclist'>
    <option value='intro'>intro</option>
    <option value='FAQ'>FAQ</option>
    <option value='features'>features</option>
    <option value='getting started'>getting started</option>
    <option value='interface [cplusplus]'>interface [cplusplus]</option>
    <option value='interface [javascript]'>interface [javascript]</option>
    <option value='interface [protobuf]'>interface [protobuf]</option>
    <option value='pathSQL basics [control]' SELECTED>pathSQL basics [control]</option>
    <option value='pathSQL basics [data]'>pathSQL basics [data]</option>
    <option value='pathSQL reference [definition]'>pathSQL reference [definition]</option>
    <option value='pathSQL reference [manipulation]'>pathSQL reference [manipulation]</option>
    <option value='pathSQL reference'>pathSQL reference</option>
    <option value='release notes'>release notes</option>
    <option value='server'>server</option>
    <option value='strengths'>strengths</option>
    <option value='terminology'>terminology</option>
    <option value='demo_EULA'>demo_EULA</option>
    <option value='demo_privacy'>demo_privacy</option>
  </select>
</div>
</div>
<div id="pathsql-basics:-control"
><h1
  >pathSQL Basics: Control</h1
  ><!-- TODO: review to make sure conventional terminology is used for each section (event handling, rules, CEP, FSM etc.) -->
<!-- TODO: review examples with singletons, when possible (to avoir errors on reruns, without extra code...) -->
<!-- TODO: augment with more examples, more services etc.; reduce to the most expressive examples -->
<!-- TODO: make sure to start with simple examples (ease in to the topic) -->
<p
  ><em
    >pathSQL</em
    > is the name of a dialect of SQL defined for Affinity: <em
    >path</em
    > refers to the ease with which chains of relationships can be built, traversed, queried, modified etc. The result is a language that preserves the declarative (non-procedural) qualities of SQL, with its well known syntax, while also integrating a very natural, flexible addressing model.</p
  ><p
  >This flexible addressing model is one of the foundations of the new control layer in AffinityNG. It facilitates the configuration of complex communication stacks and <a href="./terminology.html#fsm"
    >FSMs</a
    >, as well as the modeling of graphs (e.g. representation of a network topology). It also helps writing event handlers, by providing enough flexibility to express complex logic - as fluidly and easily as in a standard programming language (no relationship tables, unique keys, joins, temporary tables etc.).</p
  ><p
  >The examples below demonstrate how within a few declarations (&quot;lines of code&quot;), one can configure communication channels with sensors, actuators or web services; or manage state machines, express rules taking other inputs into consideration, handle complex events, etc. The resulting code and configurations can be inspected and grouped by query, modified dynamically, attached by reference or by value to log entries (e.g. for critical problem reporting and tracking), disseminated to other nodes etc.</p
  ><p
  >These running examples can also be used as a starting point to write your own applications.</p
  ><p
  >For a review of the database basics, please visit the <a href="./pathSQL%20basics%20[data].html"
    >pathSQL basics: data</a
    > page.</p
  ><p
  >For a more systematic survey of pathSQL and its commands, please visit the <a href="./pathSQL%20reference.html"
    >reference</a
    >.</p
  >To execute an example on this page, either click on it (this will redirect you to the online console), or click on the blue button in front of it (this will produce results in-place on this page).<div class="pathsql_button_fake">v</div>  
<p
  >To setup your own runtime environment, please visit this <a href="./getting%20started.html"
    >link</a
    >.</p
  ><div id="global-events"
  ><h2
    >Global Events</h2
    ><p
    >The following small program gives a quick overview of the possibilities opened up by AffinityNG's data event handlers. It creates a class for all objects containing the <code
      >example:signal</code
      > property. It annotates them with the time at which they occurred, and also inserts a trace object containing additional information (such as a pointer to the event that occurred just before, in <code
      >example:&quot;signal/previous&quot;</code
      >).</p
    ><p
    ><code class='pathsql_snippet'> SET PREFIX example: 'http://example';<br> CREATE CLASS example:reaction AS SELECT * WHERE EXISTS(example:signal)<br>  /* Whenever a PIN containing the property 'example:signal' appears, it will trigger the action defined here. */<br>  SET afy:onEnter={<br>   /* Mark the PIN with a timestamp (of when it was classified). */<br>   ${UPDATE @self ADD example:&quot;occurred/at&quot;=CURRENT_TIMESTAMP},<br>   /* Maintain a snapshot log of the chain of events. */<br>   ${INSERT example:&quot;occurred/at&quot;=@self.example:&quot;occurred/at&quot;, example:what=@self,<br>    example:previous=@ctx.example:&quot;signal/previous&quot;},<br>   /* Keep track of the last created event. */<br>   ${UPDATE @ctx SET example:&quot;signal/previous&quot;=@self}},<br>  example:&quot;signal/previous&quot;=0;<br> /* Generate a few events, for demonstration purposes. */<br> INSERT example:signal=1;<br> INSERT example:signal=2;<br> INSERT example:signal=3;<br> /* Show the results. */<br> SELECT * WHERE EXISTS(example:&quot;occurred/at&quot;); </code></p
    ><p
    >A more substantial code example can be studied via the <a href="../promo/demos/pacman/pacman.html"
      >pacman</a
      > demo.</p
    ></div
  ><div id="finite-state-machines-fsms"
  ><h2
    >Finite-State Machines (FSMs)</h2
    ><p
    >Finite-state machines will provide a more specific context for event detection and handling, and provide an easy way to connect together a set of decisions and processes. We will soon update this section with examples.</p
    ><!-- TODO: fill with a few examples when FSM data model is finalized -->
<!-- TODO: provide a link to the graphical editor, to show those examples in that form as well -->
</div
  ><div id="complex-event-processing-cep"
  ><h2
    >Complex Event Processing (CEP)</h2
    ><p
    >Built on top of basic events and <a href="#finite-state-machines-fsms"
      >FSMs</a
      >, CEP enriches the set of events available for the expression of rules and higher-order FSMs. CEP is not available yet in the alpha2 release of AffinityNG.</p
    ></div
  ><div id="rules"
  ><h2
    >Rules</h2
    ><p
    >Rules represent a higher-level layer in the programming model. They are typically used to hide implementation details, by presenting the logic of a system in quasi-natural language (provided that names were chosen appropriately by the programmers). The intent is to make it easy for non-programmer professionals to understand, adjust and customize their system.</p
    ><p
    >A rule is defined by a conjunction of conditions (i.e. a set of conditions that must all be met), and a list of actions. Internally a rule functions very much like a <a href="./terminology.html#class"
      >non-indexed class (aka simple event handler)</a
      > (indeed, the rule declaration mechanism can be thought of as a templating or macro system for classes). A rule reacts to changes on a PIN (n.b. all conditions of a rule relate to the same PIN; for multi-PIN events, see the sections on <a href="#complex-event-processing-cep"
      >CEP</a
      > and <a href="#finite-state-machines-fsms"
      >FSMs</a
      >). The <code
      >@self</code
      > variable in a rule's conditions and actions refers to the PIN being tested or processed by the rule.</p
    ><p
    >A small example:</p
    ><p
    ><code class='pathsql_snippet'> /* Internal implementation provided by the system programmer. */<br> SET PREFIX model: 'http://example/model/';<br> CREATE CONDITION model:OutsideTmpChk AS model:OutsideTemp &gt; :0;<br> CREATE CONDITION model:InsideTmpChk AS (ABS(AVG(model:InsideTempReadings) - :0)) &gt; 5dC;<br> CREATE ACTION model:Pause AS UPDATE @self SET model:PauseUntil=CURRENT_TIMESTAMP + :0,<br>  model:PausedAt=CURRENT_TIMESTAMP;<br> CREATE ACTION model:Report AS INSERT model:GlobalMessage=:0, model:FromSample=@self;<br>  <br> /* Actual rule, visible to the non-programmer professional. */<br> RULE model:HeatAlarm :<br>  model:OutsideTmpChk(25dC) AND model:InsideTmpChk(20dC) -&gt;<br>  model:Pause(INTERVAL'00:15:00'), model:Report('HeatAlarm');<br>  <br> /* Demonstrating the behavior... */<br> /* Only sample 4 should trigger the model:HeatAlarm rule. */<br> INSERT model:sample=1, model:OutsideTemp=20dC, model:InsideTempReadings={18dC, 20dC, 21dC, 20.5dC};<br> INSERT model:sample=2, model:OutsideTemp=40dC, model:InsideTempReadings={18dC, 20dC, 21dC, 20.5dC};<br> INSERT model:sample=3, model:OutsideTemp=20dC, model:InsideTempReadings={48dC, 40dC, 21dC, 20.5dC};<br> INSERT model:sample=4, model:OutsideTemp=40dC, model:InsideTempReadings={48dC, 40dC, 21dC, 20.5dC}; </code></p
    ><!-- Review: (SELECT ABS(AVG(...))), or just (ABS(AVG(...)))? -->
<!-- TODO: provide a live link to visual editor -->
</div
  ><div id="timers"
  ><h2
    >Timers</h2
    ><p
    >Timers constitute entry points of pure-pathSQL programs (analogous to the thread entry points of traditional C or java programs).</p
    ><p
    ><code class='pathsql_snippet'>CREATE TIMER _mytimer INTERVAL '00:00:30' AS INSERT _at=CURRENT_TIMESTAMP</code></p
    ><p
    ><code class='pathsql_snippet'> SET PREFIX control: 'http://example/control';<br> SET PREFIX simulation: 'http://example/simulation';<br> /* Declare a class to collect results */<br> CREATE CLASS simulation:results AS SELECT * WHERE EXISTS(simulation:&quot;rt/value&quot;);<br> /* Declare a base class of signalable entities, triggered by a single timer, below. */<br> CREATE CLASS control:&quot;rt/signalable&quot; AS SELECT * WHERE EXISTS(control:&quot;rt/time/signal&quot;);<br> /* Declare a sub-class with a specific event handler. */<br> CREATE CLASS control:&quot;step/handler/on.off.572ef13c&quot; AS SELECT * FROM control:&quot;rt/signalable&quot;<br>  WHERE control:&quot;sensor/model&quot;=.simulation:&quot;sensor/on.off.572ef13c&quot;<br>  SET afy:onUpdate={<br>   ${UPDATE @auto SET simulation:tmp1=(SELECT control:&quot;rt/time/signal&quot; FROM @self)},<br>   ${INSERT<br>    simulation:&quot;rt/value&quot;=(SELECT simulation:&quot;offset/value&quot; FROM @self) + SIN(@auto.simulation:tmp1),<br>    control:&quot;sensor/name&quot;=(SELECT control:&quot;sensor/name&quot; FROM @self),<br>    control:handler=(SELECT afy:objectID FROM @ctx),<br>    control:at=CURRENT_TIMESTAMP}};<br> /* Declare a few signalable entities. */<br> INSERT control:&quot;rt/time/signal&quot;=0, control:&quot;sensor/name&quot;='sensor A',<br>  control:&quot;sensor/model&quot;=.simulation:&quot;sensor/on.off.572ef13c&quot;, simulation:&quot;offset/value&quot;=100;<br> INSERT control:&quot;rt/time/signal&quot;=0, control:&quot;sensor/name&quot;='sensor B',<br>  control:&quot;sensor/model&quot;=.simulation:&quot;sensor/on.off.572ef13c&quot;, simulation:&quot;offset/value&quot;=1000;<br> /* Trigger all signalable entities. */<br> CREATE TIMER control:&quot;rt/source/timer&quot; INTERVAL '00:00:05' AS UPDATE control:&quot;rt/signalable&quot; SET<br>  control:&quot;rt/time/signal&quot;=EXTRACT(SECOND FROM CURRENT_TIMESTAMP), control:&quot;rt/time&quot;=CURRENT_TIMESTAMP; </code></p
    ><p
    ><code class='pathsql_snippet'> SET PREFIX simulation: 'http://example/simulation';<br> <br> /* Show results (evolving every 5 seconds... try rerunning this query a few times). */<br> SELECT * FROM simulation:results; </code></p
    ></div
  ><div id="external-services-communications"
  ><h2
    >External Services &amp; Communications</h2
    ><p
    ><a href="./pathSQL%20reference%20[definition].html#communication-pins"
      >Communication PINs</a
      >, aka &quot;CPINs&quot;, are primarily defined by their &quot;service stack&quot;. The CPIN contains its service stack via either one of these properties: <code
      >afy:service</code
      > or <code
      >afy:listen</code
      >. The former case represents passive CPINs (i.e. CPINs that will only do something when explicitly SELECT-ed or UPDATE-ed), whereas listeners can be considered active or autonomous, in the sense that no SELECT or UPDATE on them is required for them to produce changes. A service stack is a collection of <a href="./terminology.html#service"
      >services</a
      >, complemented by additional configuration properties stored on the same CPIN. Services in the stack can play different roles:</p
    ><ul
    ><li
      >source or sink (e.g. sockets, file IO, MODBUS, BLE, serial, zigbee etc.)</li
      ><li
      >request-response server (e.g. webapp, affinity)</li
      ><li
      >transformation (e.g. XML, JSON, protobuf, HTTP request/response etc.)</li
      ></ul
    ><p
    >Four basic types of service stacks, demonstrated below, emerge from these building blocks. With these and the database kernel, a multitude of communication patterns can be implemented.</p
    ><p
    ><span style='color:#444;'> <em
      >Note:</em
      > Individual services and their configurations will be described in detail <a href="./pathSQL%20reference%20[definition].html#services"
      >here</a
      >.<br
       /><em
      >Note:</em
      > In the text that follows, comments in the code fragments complement the narrative. </span></p
    ><p
    > </p
    ><!-- TODO: more examples, especially with VDEV and emergent GUI (i.e. a 'real' interaction with device and program); either cover all existing services here as a mini-ref, or add a real ref for services... need to cover things like mDNS, HTTP, NFC etc. at least to a usable state; need to document what's not working or unfinished also -->
<!-- TODO: more complex/varied stacks (refs/structs, more config, more services, server without response etc.) -->
<!-- TODO: FSM integration (e.g. security nego) -->
<ol start="0" style="list-style-type: decimal;"
    ><li
      >Let's start with a common setup for all subsequent examples. Note that these examples are inter-dependent; to avoid unexpected results, please execute them in their natural top-down sequence.</li
      ></ol
    ><p
    ><code class='pathsql_snippet'> /* Make sure the required services are loaded. */<br> CREATE LOADER _xml AS 'XML';<br> CREATE LOADER _http AS 'http';<br> CREATE LOADER _webapp AS 'webapp';<br> /* Produce debugging traces in stdout (for demonstration purposes, when running locally). */<br> SET TRACE ALL COMMUNICATIONS;<br> /* Gather some of the examples below together, to set a better example. */<br> CREATE CLASS docsamples AS SELECT * WHERE docsample_key IN :0; </code></p
    ><ol style="list-style-type: decimal;"
    ><li
      >request stack</li
      ></ol
    ><p
    ><code class='pathsql_snippet'> /* Request example: setup a XML fetcher via HTTP client. */<br> /* Here we read a CD catalog example from w3schools. */<br> /* (Could be anything: RSS feed, accessing the REST interface of an online database, etc.). */<br> /* Note: */<br> /*   Here we use the PIN declaration form (with an afy:service property); */<br> /*   in following examples, we'll use CREATE COMMUNICATION PIPELINE instead. */<br> INSERT afy:objectID='my_xml_reader1', afy:service={.srv:HTTP, .srv:sockets, .srv:HTTP, .srv:XML},<br>  afy:address='www.w3schools.com', http:url='/xml/cd_catalog.xml',<br>  http:&quot;request/fields&quot;={'Accept'-&gt;'application/xml', 'Host'-&gt;'www.w3schools.com'}, XML:&quot;config/roots&quot;={'CD'}; </code></p
    ><code class='pathsql_snippet'> /* Run the request example (n.b. this may take a second or two). */<br> SELECT * FROM #my_xml_reader1; </code><!-- TODO: show INSERT SELECT, when it will be fixed (pending issue of cross references over output stream)... -->
<p
    ><code class='pathsql_snippet'> /* Modify the URL fetched by the reader example. */<br> UPDATE RAW #my_xml_reader1 SET http:url='/xml/simple.xml', XML:&quot;config/roots&quot;={'food'};<br> /* Fetch again. */<br> SELECT * FROM #my_xml_reader1; </code></p
    ><ol start="2" style="list-style-type: decimal;"
    ><li
      >simple write stacks</li
      ></ol
    ><p
    ><code class='pathsql_snippet'> /* Writer example: transform PINs into a XML document and save to disk as a file, into /tmp. */<br> SET PREFIX testxml: 'http://test/xml';<br> CREATE COMMUNICATION PIPELINE my_xml_writer1 AS {.srv:XML, .srv:IO} SET<br>  afy:address(CREATE_PERM, WRITE_PERM, READ_PERM)='/tmp/mytest.xml',<br>  XML:&quot;config/output/qname/prefixes&quot;={'http://test/xml'-&gt;'testxml'},<br>  docsample_key=1000; </code></p
    ><p
    ><code class='pathsql_snippet'> /* Create a few PINs and demonstrate, i.e. produce /tmp/mytest.xml. */<br> SET PREFIX testxml: 'http://test/xml';<br> INSERT (testxml:x, testxml:y, testxml:name) VALUES <br>  (10,10,'Fred'), (20,20,'Jack'), (30,30,'Alicia'), (40,40,'Jane');<br> UPDATE #my_xml_writer1 SET afy:content=(SELECT * WHERE EXISTS(testxml:name)); </code></p
    ><p
    ><code class='pathsql_snippet'> /* Another example: transform PINs into protobuf this time. */<br> CREATE COMMUNICATION PIPELINE AS {.srv:protobuf, .srv:IO} SET<br>  afy:address(CREATE_PERM, WRITE_PERM, READ_PERM)='/tmp/mytest.proto',<br>  docsample_key=1001; </code></p
    ><p
    ><code class='pathsql_snippet'> /* Demonstrate, i.e. produce /tmp/mytest.proto. */<br> /* Note: By changing to 'FROM docsamples(@[1000, 1001]), */<br> /* one would simultaneously produce both mytest.xml and mytest.proto files. */<br> SET PREFIX testxml: 'http://test/xml';<br> UPDATE docsamples(1001) SET afy:content=(SELECT * WHERE EXISTS(testxml:name)); </code></p
    ><ol start="3" style="list-style-type: decimal;"
    ><li
      >server stacks</li
      ></ol
    ><p
    ><code class='pathsql_snippet'> /* Server example 1: a small web server serving files under /tmp, such as the one we just produced above. */<br> CREATE LISTENER my_http_server1 ON 4040 AS {.srv:sockets, .srv:HTTP, .srv:webapp, .srv:HTTP, .srv:sockets} SET<br>  srv:&quot;webapp/config/paths&quot;={'/tmp/'},<br>  srv:&quot;webapp/config/modes&quot;=WEBAPPMODES#FILE;<br> /* A corresponding client, fetching and parsing the xml document we had produced in the previous example. */<br> CREATE COMMUNICATION PIPELINE my_http_client1 AS {.srv:HTTP, .srv:sockets, .srv:HTTP, .srv:XML} SET<br>  afy:address='127.0.0.1:4040', http:url='/mytest.xml',<br>  http:&quot;request/fields&quot;={'Accept'-&gt;'*/*'}, http:method='GET'; </code></p
    ><p
    ><code class='pathsql_snippet'> /* Demonstrate, i.e. fetch the document served by our server. */<br> SELECT * FROM #my_http_client1; </code></p
    ><p
    ><code class='pathsql_snippet'> /* Server example 2: a server/listener interpreting a pathSQL request and returning the result as XML. */<br> CREATE LISTENER docsample_listener_xml ON 4041<br>  AS {.srv:sockets, .srv:pathSQL, .srv:affinity, .srv:XML, .srv:sockets};<br> <br> /* Server example 3: same as 2, but in protobuf. */<br> CREATE LISTENER docsample_listener_protobuf ON 4042<br>  AS {.srv:sockets, .srv:pathSQL, .srv:affinity, .srv:protobuf, .srv:sockets};<br> <br> /* Setup corresponding fetchers. */<br> SET PREFIX testxml: 'http://test/xml';<br> CREATE COMMUNICATION PIPELINE AS {.srv:pathSQL, .srv:sockets, .srv:XML} SET afy:address='127.0.0.1:4041',<br>  afy:request=${SELECT * WHERE EXISTS(testxml:name)},<br>  docsample_key=1010;<br> CREATE COMMUNICATION PIPELINE AS {.srv:pathSQL, .srv:sockets, .srv:protobuf} SET afy:address='127.0.0.1:4042',<br>  afy:request=${SELECT * WHERE EXISTS(testxml:name)},<br>  docsample_key=1011; </code></p
    ><p
    ><code class='pathsql_snippet'> /* Demonstrate server examples 2 and 3. */<br> SELECT * FROM docsamples(@[1010, 1011]); </code></p
    ><ol start="4" style="list-style-type: decimal;"
    ><li
      >simple read stacks</li
      ></ol
    ><p
    ><code class='pathsql_snippet'> /* Reader example 1: to read mytest.xml, produced above. */<br> CREATE COMMUNICATION PIPELINE AS {.srv:IO, .srv:XML} SET<br>  afy:address(READ_PERM)='/tmp/mytest.xml',<br>  docsample_key=1020;<br> <br> /* Reader example 2: to read mytest.proto, produced above. */<br> /* Note: We could also reuse the same reader; here, we also want to demonstrate */<br> /* simultaneous reading of various formats. */<br> CREATE COMMUNICATION PIPELINE AS {.srv:IO, .srv:protobuf} SET<br>  afy:address(READ_PERM)='/tmp/mytest.proto',<br>  docsample_key=1021; </code></p
    ><p
    ><code class='pathsql_snippet'> /* Just in case, reset seek pointers at the beginning of the files. */<br> UPDATE RAW docsamples(@[1020, 1021]) SET afy:position=0u;<br> /* Demonstrate, i.e. read and parse those files, and produce corresponding PINs. */<br> SELECT * FROM docsamples(@[1020, 1021]);<br> /* Variation: actually insert the parsed result back into the database (producing clones here). */<br> -- INSERT SELECT * FROM docsamples(@[1020, 1021]); </code></p
    ><!-- Review: instead of UPDATE RAW, use WITH when it's ready; document those subtleties -->
</div
  ><div id="sensors-actuators"
  ><h2
    >Sensors &amp; Actuators</h2
    ><p
    >There are several <a href="#external-services-communications"
      >services</a
      > developed for Affinity, that enable direct interactions with sensors and actuators (e.g. MODBUS, CoAP, BLE, Zigbee etc.), following the same simple pattern where SELECT reads the latest state available from those sensors, and where UPDATE writes (be it to trigger actuators, or to modify a sensor's internal state, e.g. to enable/disable/configure the on-chip sample collection [e.g. turn on&amp;off the sample collection of a more power-hungry feature or component, on a battery-powered sensor unit]).</p
    ><p
    >In this section, we'll be using the VDEV virtual device service, a service that emulates typical interactions with sensors and actuators, to illustrate some of the possibilities and idioms. Note: a similar scenario could be developed with real sensors, using something like BLE instead of VDEV; the main changes would be in terms of configuration of those CPINs.</p
    ><p
    ><span style='color:#444;'> <em
      >Note:</em
      > In the text that follows, comments in the code fragments complement the narrative. </span></p
    ><p
    > </p
    ><!-- TODO: could develop a number of representative stories here, e.g. typical PID stuff, robotics, motion, etc. -->
<!-- TODO: somewhere later in the flow, show a comparison with say BLE/MODBUS, to highlight similarities and differences with VDEV;
           emphasize that afy:address + evaluator is all it takes to get started -->
<div id="alarm-system"
    ><h3
      >Alarm System</h3
      ><p
      >The first story-line we'll be using as an example is that of an alarm system. A small <a href="#alarm-system-applet"
	>applet</a
	> is presented at the end of this section. It becomes fully operational as soon as you execute all of the code fragments that follow.</p
      ><p
      >To begin, let's imagine a contact sensor on a door, informing us of whether the door is closed:</p
      ><p
      ><code class='pathsql_snippet' loaders='CREATE LOADER _vdev AS &#39;VDEV&#39;;' dependencies='SET PREFIX alrm: &#39;http://example/alarm-system&#39;; SET PREFIX simul: &#39;http://example/alarm-system/simulation&#39;; CREATE ENUMERATION alrm:DOOR_STATES AS {&#39;OPEN&#39;, &#39;CLOSED&#39;, &#39;LOCKED&#39;}; CREATE CLASS alrm:components AS SELECT &#42; WHERE alrm:"component/id" IN :0; CREATE CLASS simul:homes AS SELECT &#42; WHERE simul:"home/id" IN :0; INSERT simul:"home/id"=&#39;147C&#39;, simul:comment=&#39;Our home state&#39;;'> /* The parts of the program that implement the alarm system itself will use the <strong
	>alrm</strong
	> prefix. */<br> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Because we want to present an interactive demo, we'll also simulate the environment; */<br> /* the parts of this program prefixed with <strong
	>simul</strong
	> would not be required in a real application */<br> /* using real sensors. */<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* Create and configure our first VDEV sensor, which will report the OPEN/CLOSED state of door 1. */<br> INSERT afy:service={.srv:VDEV}, afy:objectID=.alrm:my_first_sensor,<br>  alrm:&quot;component/id&quot;=1, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:&quot;door/state&quot; FROM simul:homes('147C').simul:doors WHERE simul:&quot;door/id&quot;=1};<br> <br> /* Add a corresponding virtual door to our environment. */<br> UPDATE simul:homes('147C') ADD simul:doors=<br>  (INSERT simul:&quot;door/id&quot;=1, simul:&quot;door/state&quot;=alrm:DOOR_STATES#CLOSED); </code></p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Test our sensor. */<br> SELECT * FROM #alrm:my_first_sensor; </code></p
      ><p
      >Note that the virtual state of our environment will be contained in a PIN accessed via <code
	>simul:homes('147C')</code
	>. For demonstration purposes, we'll simulate changes in the environment by modifying directly its simulated state. Then, we'll assess the environment (as we would in real life), using our VDEV sensors. For example, let's open the door:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* This is a simulation step, forcing a door open. */<br> UPDATE simul:homes('147C').simul:doors SET simul:&quot;door/state&quot;=alrm:DOOR_STATES#OPEN WHERE simul:&quot;door/id&quot;=1; </code></p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Here we assess the state of the door via our VDEV sensor. */<br> SELECT * FROM #alrm:my_first_sensor;<br> /* Same here, with a different (more general) access path to the same sensor. */<br> SELECT * FROM alrm:components(1); </code></p
      ><p
      >A typical home alarm system may monitor the state of several doors, windows and locks, as well as other safety parameters such as toxic gases, fire (in the form of fine particles, or ambient temperature), heat near the stove, water in the basement, etc. Let's add more sensors:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* Create and configure a few more VDEV sensors. */<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=2, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:&quot;door/state&quot; FROM simul:homes('147C').simul:doors WHERE simul:&quot;door/id&quot;=2};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=3, VDEV:&quot;read/units&quot;=0cm, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:&quot;window/state&quot; FROM simul:homes('147C').simul:windows WHERE simul:&quot;window/id&quot;=1};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=4, VDEV:&quot;read/units&quot;=0cm, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:&quot;window/state&quot; FROM simul:homes('147C').simul:windows WHERE simul:&quot;window/id&quot;=2};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=5, VDEV:&quot;read/units&quot;=0cm, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:&quot;window/state&quot; FROM simul:homes('147C').simul:windows WHERE simul:&quot;window/id&quot;=3};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=6, VDEV:&quot;read/units&quot;=0cm, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:&quot;window/state&quot; FROM simul:homes('147C').simul:windows WHERE simul:&quot;window/id&quot;=4};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=7, VDEV:&quot;read/units&quot;=0dC, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:temperature FROM simul:homes('147C').simul:floors WHERE simul:floor=1};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=8, VDEV:&quot;read/units&quot;=0dC, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:temperature FROM simul:homes('147C').simul:floors WHERE simul:floor=2};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=9, VDEV:&quot;read/units&quot;=0mg, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:particles FROM simul:homes('147C').simul:floors WHERE simul:floor=2};<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=10, VDEV:&quot;read/evaluator&quot;=<br>  ${SELECT simul:water FROM simul:homes('147C').simul:floors WHERE simul:floor=1};<br> <br> /* Add the corresponding virtual doors, windows etc. to our simulated environment. */<br> UPDATE simul:homes('147C') ADD simul:doors=<br>  (INSERT simul:&quot;door/id&quot;=2, simul:&quot;door/state&quot;=alrm:DOOR_STATES#CLOSED);<br> UPDATE simul:homes('147C') ADD simul:windows=(INSERT simul:&quot;window/id&quot;=1, simul:&quot;window/state&quot;=0cm);<br> UPDATE simul:homes('147C') ADD simul:windows=(INSERT simul:&quot;window/id&quot;=2, simul:&quot;window/state&quot;=5cm);<br> UPDATE simul:homes('147C') ADD simul:windows=(INSERT simul:&quot;window/id&quot;=3, simul:&quot;window/state&quot;=0cm);<br> UPDATE simul:homes('147C') ADD simul:windows=(INSERT simul:&quot;window/id&quot;=4, simul:&quot;window/state&quot;=20cm);<br> UPDATE simul:homes('147C') ADD simul:floors=(INSERT simul:floor=1, simul:temperature=22dC, simul:water=false);<br> UPDATE simul:homes('147C') ADD simul:floors=(INSERT simul:floor=2, simul:temperature=24dC, simul:particles=0.002mg); </code></p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Test all our sensors. */<br> SELECT * FROM alrm:components(@[1,10]); </code></p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* By simply adding RAW, show the configuration of all our sensors. */<br> SELECT RAW * FROM alrm:components(@[1,10]); </code></p
      ><p
      >An alarm system is typically implemented on a small CPU or microcontroller, which could run with Affinity. Let's sketch such an implementation. First let's define some initial state for our alarm system's controller:</p
      ><p
      ><code class='pathsql_snippet' dependencies='SET PREFIX alrm: &#39;http://example/alarm-system&#39;; CREATE ENUMERATION alrm:STATES AS {&#39;UNARMED&#39;, &#39;ARMED_PARTIAL&#39;, &#39;ARMED&#39;}; CREATE CLASS alrm:controllers AS SELECT &#42; WHERE alrm:"home/id" IN :0;'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Create a state for our alarm controller. */<br> INSERT alrm:&quot;home/id&quot;='147C', alrm:state=alrm:STATES#UNARMED,<br>  alrm:comment='The controller of our home alarm system for 147C'; </code></p
      ><p
      >The alarm system would typically have some actuators, such as a siren, and LEDs to inform of the current state (n.b. it may also take care of other things, such as controlling lights and heating while the owners are away). Let's add actuators to our system:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* Create and configure the VDEV actuators. */<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=100, VDEV:&quot;write/pin&quot;=(SELECT FIRST @ FROM simul:homes('147C')),<br>  VDEV:&quot;write/property&quot;=.simul:siren;<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=101, VDEV:&quot;write/pin&quot;=(SELECT FIRST @ FROM simul:homes('147C')),<br>  VDEV:&quot;write/property&quot;=.simul:&quot;doors/LED&quot;;<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=102, VDEV:&quot;write/pin&quot;=(SELECT FIRST @ FROM simul:homes('147C')),<br>  VDEV:&quot;write/property&quot;=.simul:&quot;windows/LED&quot;;<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=103, VDEV:&quot;write/pin&quot;=(SELECT FIRST @ FROM simul:homes('147C')),<br>  VDEV:&quot;write/property&quot;=.simul:&quot;fire/LED&quot;;<br> INSERT afy:service={.srv:VDEV}, alrm:&quot;component/id&quot;=104, VDEV:&quot;write/pin&quot;=(SELECT FIRST @ FROM simul:homes('147C')),<br>  VDEV:&quot;write/property&quot;=.simul:&quot;water/LED&quot;;<br> <br> /* Add the corresponding virtual state to our environment. */<br> UPDATE simul:homes('147C') SET<br>  simul:siren=FALSE,<br>  simul:&quot;doors/LED&quot;=FALSE,<br>  simul:&quot;windows/LED&quot;=FALSE,<br>  simul:&quot;fire/LED&quot;=FALSE,<br>  simul:&quot;water/LED&quot;=FALSE; </code></p
      ><p
      >Let's try to trigger the <code
	>.simul:siren</code
	> actuator, and see how that gets reflected in our virtual environment:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* Verify the state of the siren in the virtual environment (should be FALSE). */<br> SELECT simul:siren FROM simul:homes('147C');<br> <br> /* Trigger the siren actuator. */<br> UPDATE alrm:components(100) SET afy:content=TRUE;<br> <br> /* Verify that this action got reflected in the virtual environment. */<br> SELECT simul:siren FROM simul:homes('147C'); </code></p
      ><p
      >Now that we have demonstrated full access, via plain SELECT and UPDATE, to the sensors and actuators deployed in our environment, it becomes very easy to add logic to our controller. For example, a basic behavior would be to always report the effect of sensors on the corresponding LEDs, but only trigger the siren when the system is armed.</p
      ><p
      >Two approaches can be considered to monitor the state of our sensors: polling them periodically or, if the underlying technology allows it, listen to notifications they emit. VDEV supports both scenarios, and so do real infrastructures such as BLE. In this introductory example let's explore polling:</p
      ><p
      ><code class='pathsql_snippet' pathsql_send_at_completion='event_alarm_system_ready'> SET PREFIX alrm: 'http://example/alarm-system';<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* In response to a time event, gather readings from all sensors, and apply the desired logic. */<br> CREATE CLASS alrm:&quot;thread/entry&quot; AS SELECT * WHERE alrm:&quot;thread/entry/event&quot; IN :0<br>  SET afy:onEnter={<br>   /* Check our doors sensors. */<br>   ${UPDATE @self SET lDoors=(SELECT VDEV:&quot;read/property&quot; FROM alrm:components(@[1, 2]))},<br>   /* Check our windows sensors. */<br>   ${UPDATE @self SET lWindows=(SELECT VDEV:&quot;read/property&quot; FROM alrm:components(@[3, 6]))},<br>   /* Check our thermometers. */<br>   ${UPDATE @self SET lThermometers=(SELECT VDEV:&quot;read/property&quot; FROM alrm:components(@[7, 8]))},<br>   /* Check our fumes particles. */<br>   ${UPDATE @self SET lFumes=(SELECT VDEV:&quot;read/property&quot; FROM alrm:components(9))},<br>   /* Check our water sensor in the basement. */<br>   ${UPDATE @self SET lWater=(SELECT VDEV:&quot;read/property&quot; FROM alrm:components(10))},<br> <br>   /* Always report alerts from our readings to our LED actuators. */<br>   /* (Reminder: the basic addressing model we had setup earlier assigned */<br>   /* 100=siren, 101=doors, 102=windows, 103=fire, 104=water). */<br>   ${UPDATE @self SET lWarnDoors=(SELECT alrm:DOOR_STATES#OPEN IN lDoors FROM @self)},<br>   ${UPDATE @self SET lWarnWindows=(SELECT MAX(lWindows) &gt; 10cm FROM @self)},<br>   ${UPDATE @self SET lWarnFire=(SELECT MAX(lThermometers) &gt; 32dC OR MIN(lThermometers) &lt; 6dC OR MAX(lFumes) &gt; 0.5mg FROM @self)},<br>   ${UPDATE @self SET lWarnWater=(SELECT TRUE IN lWater FROM @self)},<br>   ${UPDATE alrm:components(101) SET afy:content=@self.lWarnDoors},<br>   ${UPDATE alrm:components(102) SET afy:content=@self.lWarnWindows},<br>   ${UPDATE alrm:components(103) SET afy:content=@self.lWarnFire},<br>   ${UPDATE alrm:components(104) SET afy:content=@self.lWarnWater},<br> <br>   /* If the alarm system is armed, then trigger the siren; otherwise, shut it down. */<br>   ${UPDATE @auto SET lArmed=(SELECT FIRST alrm:state FROM alrm:controllers('147C'))},<br>   ${UPDATE @auto SET lWarnAny=FALSE},<br>   ${UPDATE @auto SET lWarnAny=(SELECT lWarnDoors IS TRUE OR lWarnWindows IS TRUE OR<br>    lWarnFire IS TRUE OR lWarnWater IS TRUE FROM @self) WHERE @auto.lArmed&lt;&gt;alrm:STATES#UNARMED},<br>   ${UPDATE alrm:components(100) SET afy:content=@auto.lWarnAny}}; </code></p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Collect and process one test sample, by triggering alrm:&quot;thread/entry&quot;. */<br> INSERT alrm:&quot;thread/entry/event&quot;=CURRENT_TIMESTAMP; </code></p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> <br> /* Create a timer that will collect samples every 3 seconds. */<br> CREATE TIMER alrm:thread INTERVAL '00:00:03' AS INSERT alrm:&quot;thread/entry/event&quot;=CURRENT_TIMESTAMP; </code></p
      ><p
      >In the previous code fragment, we chose to set lDoors, lWindows and so on on <code
	>@self</code
	>, which means that each timer event will keep a history of the state of sensors at that time. Had we set those results on <code
	>@auto</code
	> instead, the same logic would have operated without leaving a verbose trace. Here's what we got from running so far:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> SET PREFIX simul: 'http://example/alarm-system/simulation';<br> <br> /* Show the run-time time events collected so far. */<br> SELECT * FROM alrm:&quot;thread/entry&quot;; </code></p
      ></div
    ><div id="alarm-system-applet"
    ><h3
      >Alarm System Applet</h3
      ><p
      >Provided you executed all code fragments in the <a href="#alarm-system"
	>Alarm System</a
	> section, the little applet below will let you simulate changes in the environment, and see how our alarm system reacts (<em
	>note:</em
	> the system will react asynchronously, every 3 seconds, as per our <code
	>alrm:thread</code
	> declaration earlier). You can combine those interactions with queries from the console also, and observe the results:</p
      ><p
      ><code class='pathsql_applet' pathsql_listen_to='event_alarm_system_ready'> (function() { return new function(){ var _this = this; var _pfxdef = &quot;http://example/alarm-system/simulation&quot;; var _pfx = &quot;SET PREFIX simul: '&quot; + _pfxdef + &quot;'; SET PREFIX alrm: 'http://example/alarm-system';&quot;; var _renderHouse = function(pC2d, pO) { pC2d.strokeStyle = '#000'; pC2d.strokeRect(pO.x, pO.y + 20, pO.w, pO.h - 20); pC2d.beginPath(); pC2d.moveTo(pO.x, pO.y + 20); pC2d.lineTo(pO.x + pO.w * 0.5, 0); pC2d.lineTo(pO.x + pO.w, pO.y + 20); pC2d.stroke(); }; var _renderDoor = function(pC2d, pO) { pC2d.strokeRect(pO.x, pO.y, pO.w, pO.h); if (typeof(pO.state) == 'string' &amp;&amp; pO.state.indexOf('CLOSED') &gt;= 0) { pC2d.beginPath(); pC2d.arc(pO.x + 0.66 * pO.w, pO.y + 0.6 * pO.h, 2, 0, 2 * Math.PI, true); pC2d.stroke(); } else { pC2d.beginPath(); pC2d.moveTo(pO.x, pO.y); pC2d.lineTo(pO.x + pO.w * 0.5, pO.y + pO.h * 0.5), pC2d.lineTo(pO.x + pO.w * 0.5, pO.y + pO.h * 1.5); pC2d.lineTo(pO.x, pO.y + pO.h); pC2d.closePath(); pC2d.stroke(); pC2d.fill(); } }; var _renderWindow = function(pC2d, pO) { pC2d.strokeRect(pO.x, pO.y, pO.w, pO.h); var _lH = pO.h - (pO.h * pO.state / 30); pC2d.fillRect(pO.x, pO.y, pO.w, _lH); pC2d.moveTo(pO.x, pO.y + _lH); pC2d.lineTo(pO.x + pO.w, pO.y + _lH); pC2d.stroke(); }; var _renderThermo = function(pC2d, pO) { pC2d.fillStyle = '#000'; pC2d.fillText(Math.round(pO.state), pO.x - 10, pO.y); var _lXc = pO.x + 0.5 * pO.w, _lTpct = Math.min(40.0, Math.max(0.0, pO.state)) / 40.0, _lTh = pO.h - 8; pC2d.beginPath(); pC2d.arc(_lXc, pO.y + 5, 4, 0, Math.PI, true); pC2d.arc(_lXc, pO.y + pO.h - 5, 4, Math.PI, 2 * Math.PI, true); pC2d.closePath(); pC2d.stroke(); pC2d.fillStyle = '#f00'; pC2d.strokeRect(_lXc - 2, pO.y + 4, 4, _lTh); pC2d.fillRect(_lXc - 2, pO.y + 4 + (1 - _lTpct) * _lTh, 4, _lTpct * _lTh); }; var _renderParticules = function(pC2d, pO) { /* TODO */ }; var _renderWater = function(pC2d, pO) { /* TODO */ }; var _renderAlarm = function(pC2d, pO) { pC2d.fillStyle = '#000'; pC2d.fillText(pO.name, pO.x + 12, pO.y + 3); pC2d.fillStyle = pO.state ? '#f00' : '#0f0'; pC2d.beginPath(); pC2d.arc(pO.x + 5, pO.y, 3, 0, 2 * Math.PI, true); pC2d.closePath(); pC2d.stroke(); pC2d.fill(); }; var _renderArmed = function(pC2d, pO) { pC2d.fillStyle = '#000'; pC2d.fillText(pO.name, pO.x + 12, pO.y + pO.h); pC2d.fillStyle = pO.state ? '#f00' : '#eee'; pC2d.fillRect(pO.x, pO.y, pO.w, pO.h); pC2d.strokeRect(pO.x, pO.y, pO.w, pO.h); }; var _changeDoor = function(pO, pPos) { pO.state = ((typeof(pO.state) == 'string' &amp;&amp; pO.state.indexOf('CLOSED') &gt;= 0) ? 'alrm:DOOR_STATES#OPEN' : 'alrm:DOOR_STATES#CLOSED'); return _pfx + 'UPDATE simul:homes(' + &quot;'147C'&quot; + ').simul:doors SET simul:&quot;door/state&quot;=' + pO.state + ' WHERE simul:&quot;door/id&quot;=' + pO.compId; }; var _changeWindow = function(pO, pPos) { pO.state = (30 * Math.min(pO.h, Math.max(0, pO.h - pPos.y + pO.y)) / pO.h); return _pfx + 'UPDATE simul:homes(' + &quot;'147C'&quot; + ').simul:windows SET simul:&quot;window/state&quot;=' + pO.state + 'cm WHERE simul:&quot;window/id&quot;=' + (pO.compId - 2); }; var _changeTemp = function(pO, pPos) { var _lTh = pO.h - 8; pO.state = 40.0 * (_lTh - (pPos.y - pO.y - 4)) / _lTh; return _pfx + 'UPDATE simul:homes(' + &quot;'147C'&quot; + ').simul:floors SET simul:temperature=' + pO.state + 'dC WHERE simul:floor=' + (pO.compId - 6); }; var _changeParticules = function(pO, pPos) { return ''; /* TODO */ }; var _changeWater = function(pO, pPos) { return ''; /* TODO */ }; var _changeArmed = function(pO, pPos) { pO.state = !pO.state; return _pfx + 'UPDATE alrm:controllers(' + &quot;'147C'&quot; + ') SET alrm:state=' + (pO.state ? 'alrm:STATES#ARMED' : 'alrm:STATES#UNARMED'); }; var _statesQuery = _pfx + 'SELECT * FROM alrm:components(@[1,10]);'; /* small cheat: it's actually easier to read our sensors than our states */ var _alarmsQuery = _pfx + 'SELECT alrm:state, simul:siren, simul:&quot;doors/LED&quot;, simul:&quot;windows/LED&quot;, simul:&quot;fire/LED&quot;, simul:&quot;water/LED&quot; FROM simul:homes(' + &quot;'147C'&quot; + ');'; var _controllerQuery = _pfx + 'SELECT alrm:state FROM alrm:controllers(' + &quot;'147C'&quot; + ');'; var _xh = 30; var _objectList = [ {name:'house_frame', compId:undefined, x:_xh, y:0, w:70, h:110, onRender:_renderHouse}, {name:'door1_1', compId:1, x:_xh+10, y:85, w:15, h:25, state:false, onRender:_renderDoor, onClick:_changeDoor}, {name:'door1_2', compId:2, x:_xh+45, y:85, w:15, h:25, state:false, onRender:_renderDoor, onClick:_changeDoor}, {name:'window1_1', compId:3, x:_xh+20, y:55, w:10, h:20, state:0.0, onRender:_renderWindow, onClick:_changeWindow}, {name:'window1_2', compId:4, x:_xh+40, y:55, w:10, h:20, state:0.0, onRender:_renderWindow, onClick:_changeWindow}, {name:'window2_1', compId:5, x:_xh+20, y:25, w:10, h:20, state:0.0, onRender:_renderWindow, onClick:_changeWindow}, {name:'window2_2', compId:6, x:_xh+40, y:25, w:10, h:20, state:0.0, onRender:_renderWindow, onClick:_changeWindow}, {name:'thermo1_1', compId:7, x:12, y:70, w:15, h:35, state:23.0, onRender:_renderThermo, onClick:_changeTemp}, {name:'thermo2_1', compId:8, x:12, y:25, w:15, h:35, state:23.0, onRender:_renderThermo, onClick:_changeTemp}, {name:'particules2_1', compId:9, x:_xh+90, y:25, w:10, h:10, state:0.0, onRender:_renderParticules, onClick:_changeParticules}, {name:'water1_1', compId:10, x:_xh+90, y:55, w:10, h:10, state:false, onRender:_renderWater, onClick:_changeWater}, {name:'siren', x:_xh+100, y:35, w:10, h:10, state:false, onRender:_renderAlarm}, {name:'doors', x:_xh+100, y:50, w:10, h:10, state:false, onRender:_renderAlarm}, {name:'windows', x:_xh+100, y:65, w:10, h:10, state:false, onRender:_renderAlarm}, {name:'fire', x:_xh+100, y:80, w:10, h:10, state:false, onRender:_renderAlarm}, {name:'water', x:_xh+100, y:95, w:10, h:10, state:false, onRender:_renderAlarm}, {name:'ARMED', x:_xh+100, y:10, w:10, h:10, state:true, onRender:_renderArmed, onClick:_changeArmed}, ]; this.processQueriesResults = function(pData) { var _alrm = pData[0][0]['afy:value']; _objectList[11].state = _alrm[_pfxdef + '/siren'] != 'false'; _objectList[12].state = _alrm[_pfxdef + '/doors/LED'] != 'false'; _objectList[13].state = _alrm[_pfxdef + '/windows/LED'] != 'false'; _objectList[14].state = _alrm[_pfxdef + '/fire/LED'] != 'false'; _objectList[15].state = _alrm[_pfxdef + '/water/LED'] != 'false'; var _controller = pData[2][0]; _objectList[16].state = !('http://example/alarm-system/state' in _controller) || _controller['http://example/alarm-system/state'].indexOf('UNARMED') &lt; 0; var _iO = 1; pData[1].forEach(function(_r) { _objectList[_iO].state = _r['http://affinityng.org/service/VDEV/read/property']; _iO++; }); }; this.getQueries = function() { return _alarmsQuery + _statesQuery + _controllerQuery; }; this.getObjects = function() { return _objectList; }; this.getEvalRateInMs = function() { return 2000; }; };})(); </code></p
      ><p
      >We could continue this example with more sophisticated logic, FSMs, rules, reporting to the cloud via HTTPS, XMPP or other protocols, etc. Hopefully this introductory material will inspire you to try more fun things.</p
      ><p
      >Note that to build the &quot;Sensors &amp; Actuators&quot; section that you just read, we needed a few classes and enumerations, the creation of which we didn't show (to get straight to the point). Here are their definitions:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX alrm: 'http://example/alarm-system';<br> SELECT * FROM afy:Classes WHERE BEGINS(afy:objectID, 'http://example/alarm-system/');<br> SELECT * FROM afy:Enumerations WHERE BEGINS(afy:objectID, 'http://example/alarm-system/'); </code></p
      ></div
    ></div
  ><div id="pull-model-dags"
  ><h2
    >Pull Model &amp; DAGs</h2
    ><div id="why-bother-about-a-pull-model"
    ><h3
      >Why bother about a pull model?</h3
      ><p
      >AffinityNG is a platform, that aims at lowering the barrier of entry for the design and implementation of inter-related agents (expected to multiply, in the bright near future of the Internet-of-Things). To fulfill that promise, AffinityNG provides a flexible execution model, capable of integrating common paradigms and execution patterns.</p
      ><p
      >One of these common all-purpose patterns is the &quot;pull model&quot;, allowing the dynamic construction and representation of complex processing graphs (usually directed acyclic graphs [DAGs]). These graphs combine source nodes, filtering nodes and merging nodes, each of which may be parametrizable, and may need to execute arbitrarily complex tasks to produce its output (hence the presence of caches).</p
      ><p
      >For example, this pattern is applicable to signal processing. In an image or video processing scenario for instance, source nodes may be raw or synthetic images; filtering nodes could blur their input, colorize it, add noise to it, extract a matte, or identify features in it; and merging nodes could apply various forms of blending (e.g. with or without an alpha channel). Note that a DAG is most appropriate in this context (as opposed to a simple tree), because the output of a same node may be reused by multiple nodes higher up the chain.</p
      ><p
      >The pull model pattern is equally applicable to a multitude of other processing scenarios involving animations, behaviors, simulations, circuits, spreadsheet-like active specifications, etc. Any of them may be of interest for an agent of the IoT. In this section we'll briefly illustrate how to easily implement a pull model of evaluation in AffinityNG.</p
      ></div
    ><div id="pull-model-as-an-expr-of-values"
    ><h3
      >Pull model as an <a href="./pathSQL%20reference.html#expr-expression-definition"
	>EXPR</a
	> of <a href="./terminology.html#value"
	>values</a
	></h3
      ><p
      >At a lower level, the <a href="./pathSQL%20reference.html#expr-expression-definition"
	>expression value type</a
	> in Affinity already builds upon a very flexible and powerful tree of operators (<code
	>OP_*</code
	> in <a href="./sources/affinity_h.html"
	>affinity.h</a
	>) and operands, where operands are represented by an AffinityNG <a href="./terminology.html#value"
	>value</a
	>. Evaluating an expression can be thought of as pulling on its tree. This evaluation model can already be used to perform evolved computations, as briefly demonstrated <a href="./pathSQL%20basics%20[data].html#how-to-use-lambda-expressions"
	>here</a
	>.</p
      ></div
    ><div id="pull-model-as-a-graph-of-pins"
    ><h3
      >Pull model as a graph of <a href="./terminology.html#pin"
	>PINs</a
	></h3
      ><p
      >But <a href="./terminology.html#pin"
	>PINs</a
	> and <a href="./terminology.html#service"
	>services</a
	> provide a higher-level solution (and more control), to implement a pull model of evaluation. On one hand, they allow to create, query and update a fully parametrized processing graph. Note that in this instance the operands will be whole PINs, capable of holding together their state/data, their processing code, as well as their relationships in the DAG. On the other hand, services make it trivial to bind specialized (or even customized) processing units to each node in the graph. And <a href="./terminology.html#cpin"
	>CPINs</a
	> may also be used to integrate remote nodes, fitting naturally in the pull model.</p
      ><p
      >Let's illustrate with a concrete example. We'll build a small DAG to process some bits (<em
	>note: the actual processing is meaningless here, we're just sketching the structure</em
	>). We'll also demonstrate how nodes in the DAG can notify each other when their parameters change.</p
      ><p
      ><code class='pathsql_staticschema'> (function() { return { aspect:1, instructions: [ {type:'fillRect', t:0, x:0, y:0, w:1, h:1, fillStyle:'#e4e4e4'}, /* --- */ {type:'stroke', t:0, x0:0.5, y0:0.2, x1:0.25, y1:0.45, thickness:0.02, strokeStyle:'#004400'}, {type:'stroke', t:0, x0:0.5, y0:0.2, x1:0.75, y1:0.45, thickness:0.02, strokeStyle:'#004400'}, {type:'stroke', t:0, x0:0.25, y0:0.45, x1:0.25, y1:0.75, thickness:0.02, strokeStyle:'#004400'}, {type:'strokeCircle', t:0, x:0.5, y:0.2, radius:0.07, thickness:0.02, strokeStyle:'#004400', fillStyle:'#e4e4e4'}, {type:'strokeCircle', t:0, x:0.25, y:0.45, radius:0.07, thickness:0.02, strokeStyle:'#004400', fillStyle:'#e4e4e4'}, {type:'strokeCircle', t:0, x:0.25, y:0.75, radius:0.07, thickness:0.02, strokeStyle:'#004400', fillStyle:'#e4e4e4'}, {type:'strokeCircle', t:0, x:0.75, y:0.45, radius:0.07, thickness:0.02, strokeStyle:'#004400', fillStyle:'#e4e4e4'}, {type:'fillText', t:0, x:0.5, y:0.2, dx:-0.5, dy:0.1, fillStyle:'#000000', text:'blender', font:'12pt Helvetica'}, {type:'fillText', t:0, x:0.25, y:0.45, dx:-0.5, dy:0.1, fillStyle:'#000000', text:'filter', font:'12pt Helvetica'}, {type:'fillText', t:0, x:0.25, y:0.75, dx:-0.5, dy:0.1, fillStyle:'#000000', text:'source1', font:'12pt Helvetica'}, {type:'fillText', t:0, x:0.75, y:0.45, dx:-0.5, dy:0.1, fillStyle:'#000000', text:'source2', font:'12pt Helvetica'}, /* --- */ {type:'fillText', t:0.2, duration:0.4, x:0.05, y:0.1, fillStyle:'#000066', text:'pull', font:'bold 12pt Helvetica'}, {type:'fillText', t:0.24, duration:0.36, x:0.7, y:0.65, dx:-0.5, fillStyle:'#000066', text:'request', font:'12pt Helvetica'}, {type:'strokeThickArrow', t:0.24, duration:0.28, x:0.5-0.05, y:0.07, angle:90, thickness:0.02, strokeStyle:'#000066'}, {type:'strokeThickArrow', t:0.28, duration:0.24, x:0.37-0.05, y:0.35-0.03, angle:135, thickness:0.02, strokeStyle:'#000066'}, {type:'strokeThickArrow', t:0.28, duration:0.24, x:0.63+0.05, y:0.35-0.03, angle:45, thickness:0.02, strokeStyle:'#000066'}, {type:'strokeThickArrow', t:0.32, duration:0.16, x:0.25-0.05, y:0.6, angle:90, thickness:0.02, strokeStyle:'#000066'}, /* --- */ {type:'fillText', t:0.4, duration:0.2, x:0.7, y:0.75, dx:-0.5, fillStyle:'#006600', text:'response', font:'12pt Helvetica'}, {type:'strokeThickArrow', t:0.48, duration:0.08, x:0.5+0.05, y:0.07, angle:-90, thickness:0.02, strokeStyle:'#006600'}, {type:'strokeThickArrow', t:0.44, duration:0.12, x:0.37+0.03, y:0.35+0.02, angle:-45, thickness:0.02, strokeStyle:'#006600'}, {type:'strokeThickArrow', t:0.4, duration:0.16, x:0.63-0.03, y:0.35+0.02, angle:-135, thickness:0.02, strokeStyle:'#006600'}, {type:'strokeThickArrow', t:0.4, duration:0.16, x:0.25+0.05, y:0.6, angle:-90, thickness:0.02, strokeStyle:'#006600'}, /* --- */ {type:'fillText', t:0.7, duration:0.2, x:0.05, y:0.1, fillStyle:'#440000', text:'invalidation', font:'bold 12pt Helvetica'}, {type:'strokeThickArrow', t:0.78, duration:0.08, x:0.37+0.05, y:0.35, angle:-45, thickness:0.02, strokeStyle:'#440000'}, {type:'strokeThickArrow', t:0.74, duration:0.12, x:0.63-0.05, y:0.35, angle:-135, thickness:0.02, strokeStyle:'#440000'}, {type:'strokeThickArrow', t:0.74, duration:0.12, x:0.25+0.05, y:0.6, angle:-90, thickness:0.02, strokeStyle:'#440000'}, {type:'strokeThickArrow', t:0.7, duration:0.16, x:0.12, y:0.75, angle:0, thickness:0.02, strokeStyle:'#440000'}, {type:'strokeThickArrow', t:0.7, duration:0.16, x:0.12, y:0.45, angle:0, thickness:0.02, strokeStyle:'#440000'}, {type:'strokeThickArrow', t:0.7, duration:0.16, x:0.88, y:0.45, angle:180, thickness:0.02, strokeStyle:'#440000'}, ] };})(); </code></p
      ><p
      >In our code example, each node in the DAG will be represented by up to 3 distinct, inter-connected PINs:</p
      ><ul
      ><li
	>the node itself, knowing its input nodes (<code
	  >dag:input1</code
	  > etc.), and also pointing to a ghost of itself (<code
	  >dag:ghost</code
	  >), as well as to a separate optional PIN for its parameters (<code
	  >dag:parameters</code
	  >); the node may also contain a cache of its last output evaluation (<code
	  >dag:cache</code
	  >)</li
	><li
	>the ghost knows its logical outputs (<code
	  >dag:&quot;ghost/parents&quot;</code
	  >), and thus forms a notification chain parallel to the actual DAG of nodes (<em
	  >note:</em
	  > this separation is essentially for convenience, to facilitate using <code
	  >afy:onUpdate</code
	  > for this purpose); the ghost also has a back-pointer to its <code
	  >dag:&quot;owner/node&quot;</code
	  >, as well as a <code
	  >dag:&quot;invalidation/id&quot;</code
	  >, which reflects the last logical time it was invalidated</li
	><li
	>the optional PIN to hold a node's parameters knows its owner (via <code
	  >dag:parametrizes</code
	  >), and thus can initiate a notification up the chain</li
	></ul
      ><p
      >First, let's produce a simple demonstration DAG, where the top node has 2 inputs, its first input has 1, and its second input is directly a source. Here we insert the whole DAG in a single statement, for fun (in a real-life scenario this would more likely be the result of a gradual construction). The actual processing in the current example simply manipulates a bit array:</p
      ><p
      ><code class='pathsql_snippet' loaders='CREATE LOADER _vdev AS &#39;VDEV&#39;;' dependencies='SET PREFIX dag: &#39;http://example/pullmodel&#39;; SET TRACE ALL ACTIONS; SET TRACE ALL COMMUNICATIONS; INSERT afy:objectID=.dag:stdout, afy:service={.srv:IO}, afy:address=1;'> SET PREFIX dag: 'http://example/pullmodel';<br> <br> /* =========================================== */<br> /* ROOT NODE (A TWO-INPUT <strong
	>BLENDER</strong
	> [NO PARAMS]) */<br> /* =========================================== */<br> INSERT @:1 afy:service={.srv:VDEV},<br>  afy:objectID=.dag:root,<br>  dag:ghost=(INSERT @:10001 dag:&quot;owner/node&quot;=@:1, dag:&quot;invalidation/id&quot;=0),<br>  VDEV:&quot;read/evaluator&quot;={<br>   /* Pull our inputs (caching their outputs at the same time). */<br>   ${UPDATE :0 SET dag:cache1=(SELECT FIRST VDEV:&quot;read/property&quot; FROM :0.dag:input1)},<br>   ${UPDATE :0 SET dag:cache2=(SELECT FIRST VDEV:&quot;read/property&quot; FROM :0.dag:input2)},<br>   /* Process our output: here, the bits of our first input minus the bits of our second. */<br>   /* Note: the result of our VDEV service is produced by its last statement. */<br>   ${UPDATE :0 SET dag:cache=(SELECT dag:cache1 &amp; ~dag:cache2 FROM :0)},<br>   ${SELECT dag:cache FROM :0}},<br>  VDEV:&quot;evaluation/parameters&quot;=<br>   (INSERT<br> <br>    dag:input1=<br> <br>     /* ================================================== */<br>     /* ROOT's INPUT1 (A PARAMETRIZED SINGLE-INPUT <strong
	>FILTER</strong
	>) */<br>     /* ================================================== */<br>     (INSERT @:11 afy:service={.srv:VDEV},<br>      dag:ghost=(INSERT @:10011 dag:&quot;owner/node&quot;=@:11, dag:&quot;ghost/parents&quot;=@:10001, dag:&quot;invalidation/id&quot;=0),<br>      VDEV:&quot;read/evaluator&quot;={<br>       /* Pull our input. */<br>       ${UPDATE :0 SET dag:cache=(SELECT FIRST VDEV:&quot;read/property&quot; FROM :0.dag:input)},<br>       /* ${UPDATE #dag:stdout SET afy:content='=== Did produce cache of root input1 ==='},*/<br>       /* Process our output: the bits of our input shifted to the left. */<br>       ${SELECT dag:cache &amp; dag:mask FROM :0}},<br>      VDEV:&quot;evaluation/parameters&quot;=<br>       (INSERT<br>        dag:mask=X'FF00FF00FF00', /* (Note: this is the filter's parameter) */<br>        dag:input=<br> <br>         /* ====================================== */<br>         /* INPUT1's INPUT (A PARAMETRIZED <strong
	>SOURCE</strong
	>) */<br>         /* ====================================== */<br>         (INSERT @:111 afy:service={.srv:VDEV},<br>          dag:ghost=(INSERT dag:&quot;owner/node&quot;=@:111, dag:&quot;ghost/parents&quot;=@:10011, dag:&quot;invalidation/id&quot;=0),<br>          VDEV:&quot;read/evaluator&quot;=${SELECT dag:&quot;source/bytes&quot; FROM :0},<br>          VDEV:&quot;evaluation/parameters&quot;=(INSERT dag:parametrizes=@:11, dag:&quot;source/bytes&quot;=X'010101010101')))),<br> <br>    dag:input2=<br> <br>     /* ===================================== */<br>     /* ROOT's INPUT2 (A PARAMETRIZED <strong
	>SOURCE</strong
	>) */<br>     /* ===================================== */<br>     (INSERT @:12 afy:service={.srv:VDEV},<br>      dag:ghost=(INSERT dag:&quot;owner/node&quot;=@:12, dag:&quot;ghost/parents&quot;=@:10001, dag:&quot;invalidation/id&quot;=0),<br>      VDEV:&quot;read/evaluator&quot;=${SELECT dag:&quot;source/bytes&quot; FROM :0},<br>      VDEV:&quot;evaluation/parameters&quot;=(INSERT afy:objectID=.dag:source2, dag:parametrizes=@:12, dag:&quot;source/bytes&quot;=X'000000001111')));<br> </code></p
      ><p
      >Now let's see our DAG at work. First, we'll just evaluate it in its present state:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX dag: 'http://example/pullmodel';<br> SELECT VDEV:&quot;read/property&quot; FROM #dag:root; </code></p
      ><p
      >It should have cached its own output (in <code
	>dag:cache</code
	>):</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX dag: 'http://example/pullmodel';<br> SELECT RAW * FROM #dag:root.VDEV:&quot;evaluation/parameters&quot;; </code></p
      ><p
      >Let's define some notification logic, to automatically invalidate nodes in the DAG upon changes in a node's parameters:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX dag: 'http://example/pullmodel';<br> <br> /* Starting a new notification chain, due to local changes. */<br> CREATE CLASS dag:&quot;invalidation/initiator&quot; AS SELECT *<br>  WHERE EXISTS(dag:parametrizes)<br>  SET afy:onUpdate={<br>   ${UPDATE RAW @self.dag:parametrizes DELETE dag:cache},<br>   ${UPDATE RAW @self.dag:parametrizes.dag:ghost SET dag:&quot;invalidation/id&quot;+=1}}; <br> /* Walking up the notification chain. */<br> CREATE CLASS dag:&quot;invalidation/propagator&quot; AS SELECT *<br>  WHERE EXISTS(dag:&quot;invalidation/id&quot;) AND EXISTS(dag:&quot;owner/node&quot;)<br>  SET afy:onUpdate={<br>   /* Determine if we have reached a root. */<br>   ${UPDATE @auto SET _lIsRoot=(SELECT NOT EXISTS(dag:&quot;ghost/parents&quot;) FROM @self)},<br>   /* If there's a parent node, keep invalidating upward. */<br>   ${UPDATE @auto SET _lUpdateParents=<br>    (UPDATE @self.dag:&quot;ghost/parents&quot; SET dag:&quot;invalidation/id&quot;+=1)<br>    WHERE @auto._lIsRoot IS FALSE},<br>   /* Otherwise if we've reached the root, pull and cache result. */<br>   ${UPDATE RAW @self.dag:&quot;owner/node&quot; set dag:cache=<br>    (SELECT VDEV:&quot;read/property&quot; FROM @self.dag:&quot;owner/node&quot;)<br>    WHERE @auto._lIsRoot IS TRUE}};<br> </code></p
      ><p
      >Now, let's modify one of the sources:</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX dag: 'http://example/pullmodel';<br> UPDATE RAW #dag:root.VDEV:&quot;evaluation/parameters&quot;.dag:input2.VDEV:&quot;evaluation/parameters&quot; SET dag:&quot;source/bytes&quot;=X'111100000000'; </code></p
      ><p
      >It should have triggered an automatic re-evaluation, so let's see if the output changed, but without pulling on it this time (the fresh output should already be in <code
	>dag:cache</code
	>, thanks to the notification logic we just put in place):</p
      ><p
      ><code class='pathsql_snippet'> SET PREFIX dag: 'http://example/pullmodel';<br> SELECT RAW * FROM #dag:root.VDEV:&quot;evaluation/parameters&quot;; </code></p
      ></div
    ></div
  ><div id="introspection-code-querying"
  ><h2
    >Introspection &amp; Code Querying</h2
    ><p
    >Being together a database, a runtime engine, and a communication hub spanning across and tying together very diverse sources of information, with all information represented in a uniform manner (via the PIN), Affinity provides an environment where it becomes easy to obtain information by query, about states and behaviors that may be opaque, or require much more labor-intensive inquiry processes in other environments.</p
    ><p
    >For example, following the examples for <a href="#external-services-communications"
      >communication PINs</a
      > in previous sections of this page, one may want to find out all CPINs dealing with XML:</p
    ><p
    ><code class='pathsql_snippet'> /* Get all CPINs dealing with XML. */<br> SELECT RAW * WHERE (.srv:XML IN afy:service) OR (.srv:XML IN afy:listen); </code></p
    ><p
    >There are plenty of other available queries to explore code, data, and relationships between them, such as:</p
    ><p
    ><code class='pathsql_snippet'> /* Get all existing classes. */<br> SELECT * FROM afy:Classes;<br> /* Get all existing classes of a package. */<br> SELECT * FROM afy:Classes WHERE BEGINS(afy:objectID, 'http://pacman1/'); </code></p
    ><p
    ><code class='pathsql_snippet'> /* Get all FSM states. */<br> SELECT * WHERE EXISTS(afy:transition); </code></p
    ><p
    ><code class='pathsql_snippet'> /* Find all classes inspecting a property name containing 'docsample'. */<br> SELECT * FROM afy:Classes WHERE CONTAINS(afy:predicate, 'docsample');</br> /* Find all timers inspecting a property name containing 'signal'. */<br> SELECT * FROM afy:Timers WHERE CONTAINS(afy:action, 'signal'); </code></p
    ><p
    >The <a href="../console.html#tab-fsm"
      >FSM</a
      > and <a href="../console.html#tab-ruleassistant"
      >Rule Assistant</a
      > tabs of the web console make use of these capabilites to help the user narrow down and pinpoint relevant code visualizations, for a given circumstance (e.g. show all code using a certain <a href="./terminology.html#property"
      >property</a
      > or <a href="./terminology.html#class"
      >class</a
      >).</p
    ><!-- TODO: review (more meat) with FSMs -->
<!-- TODO: an example with FT search (MATCH AGAINST + an indexed prop; take that opportunity to review all usage of the modeling.py data model [indexing meta]) -->
</div
  ><div id="logging"
  ><h2
    >Logging</h2
    ><p
    >The examples provided above (<a href="#global-events"
      >events</a
      > and <a href="#rules"
      >rules</a
      >) give a hint of how current time, current topology, current state, current code etc. could be attached to a log entry (by reference or by value). In the near future, we will provide a more significant example here.</p
    ><!-- TODO: show how current time, current topology, current state, current code etc.
can be attached to a log entry, by ref or by value; easiest would be to attach to the timer above,
if bug #357 is fixed in time; otherwise, build a complete mini-example here (relatively trivial to do) -->

<!-- Synergy
The very open nature of [PINs](./terminology.html#pin), combined with the way all active components
are configured, allows to merge together mutliple functionalities into a single PIN naturally,
with automatic handling in the kernel of implied aspects. 
In a next revision of the doc, we will provide concrete examples.
<!-- TODO agree on exact definition, scenarios, convincing examples --
-->

</div
  ></div
>
</div>
