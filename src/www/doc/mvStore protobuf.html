<head>
  <script src='js/jquery.js' type='text/javascript'></script>
  <script src='js/snippets_to_console.js' type='text/javascript'></script>
  <link href='css/mvdoc.css' rel='stylesheet' type='text/css' />
</head>
<div id='mvtocbar'>
  <select id='mvtoclist'>
    <option value='features'>features</option>
    <option value='intro'>intro</option>
    <option value='mvEngine getting started'>mvEngine getting started</option>
    <option value='mvSQL getting started'>mvSQL getting started</option>
    <option value='mvSQL reference'>mvSQL reference</option>
    <option value='mvStore FAQ'>mvStore FAQ</option>
    <option value='mvStore build from source'>mvStore build from source</option>
    <option value='mvStore cpp'>mvStore cpp</option>
    <option value='mvStore getting started'>mvStore getting started</option>
    <option value='mvStore js'>mvStore js</option>
    <option value='mvStore protobuf' SELECTED>mvStore protobuf</option>
    <option value='mvStore server'>mvStore server</option>
    <option value='strengths'>strengths</option>
    <option value='terminology'>terminology</option>
  </select>
</div
<div id="protocol-buffer-interface-for-mvstore"
><h1
  >Protocol-Buffer Interface for mvStore</h1
  ><p
  >Protocol-Buffers (aka <em
    >protobuf</em
    >) are Google's open-source interchange format. This format was designed to provide generic encoding and decoding of structured data in an efficient manner (that is both language and platform neutral). It enjoyed a popularity that resulted in widespread support across many platforms.</p
  ><p
  >mvStore uses protobuf as a vehicle to export data outside of a store, and to import data (or updates) into a store. As such, protobuf can be viewed as another interface to mvStore, albeit a rather low-level interface. In most cases, the developer writing client code for mvStore is not expected to interact directly with protobuf.</p
  ><p
  >There are several obvious situations where the protobuf interface can be useful: dump &amp; load, replication, inter-store messaging etc.</p
  ><p
  >Another important use case is when protobuf is combined with <a href="./terminology.html#mvsql"
    >mvSQL</a
    > to implement language-specific access layers for mvStore (aka <a href="./terminology.html#client-side-libraries"
    >client libraries</a
    >). In this context, protobuf acts as a middle-man between the language's object model <em
    >(effectively allowing to export/serialize objects outside of the language and import/deserialize objects back into the language)</em
    > and mvStore's own data model. This reduces considerably the need for an ORM when using mvStore <em
    >(because mvStore's internal data model maps directly with the core native object model of most languages)</em
    >.</p
  ><p
  >Here are two typical examples.</p
  ><p
  >A client <em
    >writes</em
    > to mvStore:</p
  ><p
  >the client has a javascript object to be stored in mvStore -&gt; the client serializes it to protobuf, as a new object to be inserted (OP_INSERT) -&gt; the client sends the serialized stream to mvStore -&gt; mvStore deserializes the protobuf stream into its own internal data model -&gt; mvStore detects OP_INSERT and stores the new object -&gt; mvStore produces a response (including new PID, new eids etc.) -&gt; mvStore serializes the response to protobuf -&gt; the client deserializes the response</p
  ><p
  >A client <em
    >reads</em
    > from mvStore:</p
  ><p
  >the client wants to query PIN @50001 and interact with it as an object -&gt; the client emits the query 'SELECT * FROM @50001;' via a protobuf-enabled interface -&gt; mvStore executes the query and serializes the response to protobuf -&gt; the client deserializes the response into a javascript object</p
  ><p
  >The internal structure of the protobuf messages that can be understood by mvStore is defined in <a href="../kernel/src/mvstore.proto"
    >mvstore.proto</a
    >. It allows to express PIN inserts, updates and deletes, as well as generic queries, transactions, long-running transactions etc. It also provides extensive support for fine-grained updates, such as modifying the order of elements in a collection (e.g. <code
    >OP_MOVE_BEFORE</code
    >), performing server-side read-modify-write on specific properties (e.g. <code
    >OP_PLUS</code
    >), etc.</p
  ><p
  ><em
    >Note: The process of serializing to protobuf and deserializing back into a client's object model may require a translation. Even though protobuf libraries typically produce a language-compliant structure, that structure is defined by mvstore.proto, for serialization purposes, and may not be sufficiently usable as a client object model. For example, mvstore.proto stores all property names as indexes, alongside a local translation table (for space efficiency). Typically, most languages will prefer to expose objects in a more natural form, where properties are standard named entities. This kind of translation is usually implemented in the client access library (e.g. <a href="../nodejs/mvstore-client/lib/mvstore-client.js"
      >mvstore-client.js</a
      > or <a href="../python/mvstore.py"
      >mvstore.py</a
      >).</em
    ></p
  ><div id="a-closer-look-at-mvstore.proto"
  ><h3
    >A Closer Look at mvstore.proto</h3
    ><p
    >All the components of a protobuf stream sent to or received from mvStore are defined in <a href="../kernel/src/mvstore.proto"
      >mvstore.proto</a
      >. The main elements of the structure are:</p
    ><ul
    ><li
      >Value</li
      ><li
      >PID</li
      ><li
      >MVStream.PIN</li
      ><li
      >MVStream.MVSQL</li
      ><li
      >MVStream</li
      ></ul
    ><p
    ><code
      >Value</code
      > corresponds to the <a href="./terminology.html#value"
      >basic notion of value</a
      > used throughout the documentation, and constitutes the main building block of a <code
      >MVStream.PIN</code
      > (the <a href="./terminology.html#pin"
      >PIN</a
      >). <code
      >PID</code
      > defines the serialization format of <a href="./terminology.html#pin-id-pid"
      >PIN IDs</a
      >, which are generated by mvStore initially, and are then used to refer to existing PINs (e.g. to read, modify or delete them). <code
      >MVStream.MVSQL</code
      > allows to insert mvSQL statements in a protobuf stream (thus implying a serialized query result in the protobuf response, often in the form of an array of <code
      >MVStream.PIN</code
      > objects).</p
    ><p
    ><code
      >MVStream</code
      > defines the possible contents of any of the contiguous segments of data in the actual physical stream. In other words, it should be possible to dissect any physical stream compliant with <a href="../kernel/src/mvstore.proto"
      >mvstore.proto</a
      > and find a series of <code
      >MVStream</code
      > instances.</p
    ><p
    >For example, the physical input and output streams involved in fetching a PIN, testing some conditions and then modifying the PIN in a single transaction could look like this (where each column is a physical stream, and each row represents one <code
      >MVStream</code
      > segment of it):</p
    ><table
    ><thead
      ><tr class="header"
	><th align="left"
	  >Physical stream sent to mvStore</th
	  ><th align="left"
	  >Physical stream returned by mvStore</th
	  ></tr
	></thead
      ><tbody
      ><tr class="odd"
	><td align="left"
	  >{ txop:[TX_START] }</td
	  ><td align="left"
	  ></td
	  ></tr
	><tr class="even"
	><td align="left"
	  >{ stmt:[{ sq:&quot;SELECT * FROM @50001;&quot;, rtt:RT_PINS }], flush:[0] }</td
	  ><td align="left"
	  ></td
	  ></tr
	><tr class="odd"
	><td align="left"
	  ></td
	  ><td align="left"
	  >{ result:[...], properties:[...], pins:[{ id:{ id:50001 }, values:[...], ... }] }</td
	  ></tr
	><tr class="even"
	><td align="left"
	  ><em
	    >Note: Here comes the client-side logic to decide what to do with the PIN.</em
	    ></td
	  ><td align="left"
	  ></td
	  ></tr
	><tr class="odd"
	><td align="left"
	  >{ pins:[{ op:OP_UPDATE, id:{ id:50001 }, ... }], properties:[...], flush:[0] }</td
	  ><td align="left"
	  ></td
	  ></tr
	><tr class="even"
	><td align="left"
	  ></td
	  ><td align="left"
	  >{ result:[...], properties:[...], pins:[{ id:{ id:50001 }, ... }] }</td
	  ></tr
	><tr class="odd"
	><td align="left"
	  >{ txop:[TX_COMMIT] }</td
	  ><td align="left"
	  ></td
	  ></tr
	><tr class="even"
	><td align="left"
	  ></td
	  ><td align="left"
	  >{ result:[...] }</td
	  ></tr
	></tbody
      ></table
    ><p
    ><sub> Note: This sequence is typically implemented as a single HTTP connection. </sub></p
    ><p
    ><a href="../kernel/src/mvstore.proto"
      >mvstore.proto</a
      > contains more structures and fields than described here. It also contains a large number of <code
      >enums</code
      >, some of which are sometimes used as constants <em
      >(n.b.: some protobuf libraries don't support this strategy, in which case the values in mvstore.proto must be repeated as literals in the client code)</em
      >. Please refer to the comments in <a href="../kernel/src/mvstore.proto"
      >mvstore.proto</a
      > for more information.</p
    ></div
  ><div id="about-streaming-and-pagination"
  ><h3
    >About Streaming and Pagination</h3
    ><p
    >mvStore offers two distinct and complementary strategies for dealing with data streaming.</p
    ><p
    >The simplest strategy consists in letting the client specify pagination OFFSET and LIMIT along with its mvSQL statement. This can be done via <code
      >MVStream.MVSQL.offset</code
      > and <code
      >MVStream.MVSQL.limit</code
      > (directly in the protobuf request). <a href="./mvStore%20server.html"
      >mvServer</a
      > also allows to specify these parameters. mvStore interprets them and returns a subset of the whole result set <em
      >(n.b. in the current implementation, the query is re-evaluated for every requested page; consistency can be secured with a transaction, but the performance is not optimal)</em
      >. The granularity is the PIN, which may be insufficient in some cases, such as data models involving huge collections.</p
    ><p
    >The second strategy involves a different method of reading the response stream, one atomic element at a time (instead of one <code
      >MVStream</code
      >-segment at a time). This strategy provides full control over the stream (and the memory footprint involved in reading it). On the other hand, it also comes at a cost: on one hand, it usually implies a completely different programming model (if you can't afford to put a whole PIN in memory, then you probably can't interact with that object as a native object either); on the other hand, not all protobuf libraries expose this kind of access.</p
    ><p
    >In their present implementation, the <a href="../nodejs/mvstore-client/lib/mvstore-client.js"
      >node.js</a
      > and <a href="../python/mvstore.py"
      >python</a
      > client libraries only support the first strategy, but may expose a specialized interface using the second strategy in a near future.</p
    ></div
  ><div id="more-information"
  ><h3
    >More Information</h3
    ><p
    >For more information on mvStore's usage of protobuf, please refer to the comments in <a href="../kernel/src/mvstore.proto"
      >mvstore.proto</a
      >. Another important source of information is the implementation of the <a href="../nodejs/mvstore-client/lib/mvstore-client.js"
      >node.js</a
      > and <a href="../python/mvstore.py"
      >python</a
      > access layers, which can be used as examples to implement new access layers.</p
    ><p
    >For more information about Google's protobuf, please refer to the project's <a href="http://code.google.com/p/protobuf"
      >homepage</a
      >, its <a href="http://code.google.com/apis/protocolbuffers/docs/overview.html"
      >deleloper guide</a
      > and its <a href="http://code.google.com/apis/protocolbuffers/docs/proto.html"
      >format helper</a
      >.</p
    ></div
  ></div
>
