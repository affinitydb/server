<head>
  <link href='../css/afydoc.css' rel='stylesheet' type='text/css' />
  <link href='../css/source.css' rel='stylesheet' type='text/css' />
</head>
<div id="affinity_h">
<h1>affinity.h</h1>

<!-- begin highlighted code -->
<div class="highlight"><pre><span class="cm">/**************************************************************************************</span>

<span class="cm">Copyright Â© 2004-2014 GoPivotal, Inc. All rights reserved.</span>

<span class="cm">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm">you may not use this file except in compliance with the License.</span>
<span class="cm">You may obtain a copy of the License at</span>

<span class="cm">     http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="cm">Unless required by applicable law or agreed to in writing, software</span>
<span class="cm">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,  WITHOUT</span>
<span class="cm">WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span>
<span class="cm">License for the specific language governing permissions and limitations</span>
<span class="cm">under the License.</span>

<span class="cm">Written by Mark Venguerov 2004-2014</span>

<span class="cm">**************************************************************************************/</span>

<span class="cp">#ifndef _AFFINITY_H_</span>
<span class="cp">#define _AFFINITY_H_</span>

<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="cp">#include &lt;stddef.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;assert.h&gt;</span>

<span class="cp">#include &quot;rc.h&quot;</span>
<span class="cp">#include &quot;units.h&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">AfyRC</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Namespace to encapsulate the public interface of Affinity.</span>
<span class="cm"> * Overview:</span>
<span class="cm"> *  ISession represents a client&#39;s connection to the store.</span>
<span class="cm"> *  IPIN represents a PIN, i.e. a node of information.</span>
<span class="cm"> *  Through its ISession, a client can create, query, modify and delete PINs, control transactions, set session parameters, etc.</span>
<span class="cm"> *  Through IPIN, one can create, query, modify and delete properties or clone the PIN optionally overwriting properties.</span>
<span class="cm"> */</span>
<span class="n">namespace</span> <span class="n">Afy</span> 
<span class="p">{</span>
	<span class="k">typedef</span>	<span class="kt">uint32_t</span>					<span class="n">IdentityID</span><span class="p">;</span>						<span class="cm">/**&lt; Identity ID - used to represent an identity in this store */</span>
	<span class="k">typedef</span>	<span class="kt">uint32_t</span>					<span class="n">URIID</span><span class="p">;</span>							<span class="cm">/**&lt; URI ID - used to represent a URI in this store */</span>
	<span class="k">typedef</span>	<span class="n">URIID</span>						<span class="n">ClassID</span><span class="p">;</span>						<span class="cm">/**&lt; Class ID - used to represent the class URI in this store */</span>
	<span class="k">typedef</span>	<span class="n">URIID</span>						<span class="n">PropertyID</span><span class="p">;</span>						<span class="cm">/**&lt; Property ID - same as URIID */</span>
	<span class="k">typedef</span>	<span class="kt">uint32_t</span>					<span class="n">ElementID</span><span class="p">;</span>						<span class="cm">/**&lt; Immutable collection element ID */</span>
	<span class="k">typedef</span>	<span class="kt">uint32_t</span>					<span class="n">VersionID</span><span class="p">;</span>						<span class="cm">/**&lt; Version number */</span>
	<span class="k">typedef</span>	<span class="kt">uint64_t</span>					<span class="n">TIMESTAMP</span><span class="p">;</span>						<span class="cm">/**&lt; Timestamp in miscroseconds since start date */</span>

<span class="cp">	#define	STORE_INVALID_PID			0ULL</span>
<span class="cp">	#define	STORE_INVALID_URIID			(~Afy::PropertyID(0))	</span>
<span class="cp">	#define	STORE_INVALID_IDENTITY		(~Afy::IdentityID(0))	</span>
<span class="cp">	#define	STORE_INMEM_IDENTITY		(~Afy::IdentityID(1))</span>
<span class="cp">	#define	STORE_INVALID_CLASSID		STORE_INVALID_URIID</span>
<span class="cp">	#define	STORE_CURRENT_VERSION		(~Afy::VersionID(0))	</span>
<span class="cp">	#define	STORE_MAX_URIID				Afy::URIID(0x1FFFFFFF)				</span><span class="cm">/**&lt; Maximum value for URIID */</span><span class="cp"></span>
<span class="cp">	#define	STORE_OWNER					Afy::IdentityID(0)					</span><span class="cm">/**&lt; The owner of the store always has IdentityID equals to 0 */</span><span class="cp"></span>

<span class="cp">	#define	AFFINITY_URI_PREFIX			&quot;http:</span><span class="c1">//affinityng.org/&quot;			/**&lt; URI prefix for Affinity URIs */</span>
<span class="cp">	#define	AFFINITY_STD_URI_PREFIX		&quot;http:</span><span class="c1">//affinityng.org/builtin/&quot;	/**&lt; URI prefix for built-in Affinity URIs */</span>
<span class="cp">	#define	AFFINITY_STD_QPREFIX		&quot;afy:&quot;								</span><span class="cm">/**&lt; Qname prefix for built-in URIs */</span><span class="cp"></span>
<span class="cp">	#define	AFFINITY_SERVICE_PREFIX		&quot;http:</span><span class="c1">//affinityng.org/service/&quot;	/**&lt; URI prefix for service URIs */</span>
<span class="cp">	#define	AFFINITY_SRV_QPREFIX		&quot;srv:&quot;								</span><span class="cm">/**&lt; Qname prefix for services, both built-in and external */</span><span class="cp"></span>
<span class="cp">	#define	AFFINITY_STORE_QPREFIX		&quot;store:&quot;							</span><span class="cm">/**&lt; Qname prefix for #names, added automatically */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * special property and class IDs</span>
<span class="cm">	 */</span>
<span class="cp">	#define	CLASS_OF_CLASSES			Afy::ClassID(0)				</span><span class="cm">/**&lt; Fixed ID of the class of all classes in the store */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_TIMERS				Afy::ClassID(1)				</span><span class="cm">/**&lt; Class of all timers */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_LISTENERS			Afy::ClassID(2)				</span><span class="cm">/**&lt; Class of all listeners */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_LOADERS			Afy::ClassID(3)				</span><span class="cm">/**&lt; Class of all loaders (i.e. PINs describing external loadable service libraries) */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_PACKAGES			Afy::ClassID(4)				</span><span class="cm">/**&lt; Class of all installed packages */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_NAMED				Afy::ClassID(5)				</span><span class="cm">/**&lt; Class of all globally named PINs (i.e. having PROP_SPEC_OBJID) */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_ENUMS				Afy::ClassID(6)				</span><span class="cm">/**&lt; Class of enumerations */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_STORES				Afy::ClassID(7)				</span><span class="cm">/**&lt; Class of known stores */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_SERVICES			Afy::ClassID(8)				</span><span class="cm">/**&lt; Class of registered services */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_FSMCTX				Afy::ClassID(9)				</span><span class="cm">/**&lt; Class of all persistent FSM contexts */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_FSMS				Afy::ClassID(10)			</span><span class="cm">/**&lt; Class of FSMs */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_OF_HANDLERS			Afy::ClassID(11)			</span><span class="cm">/**&lt; Class of event handlers */</span><span class="cp"></span>
<span class="cp">	</span>
<span class="cp">	#define	PROP_SPEC_PINID				Afy::PropertyID(17)			</span><span class="cm">/**&lt; PIN id as PIN&#39;s property, immutable */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_DOCUMENT			Afy::PropertyID(18)			</span><span class="cm">/**&lt; document PIN this PIN is a part of */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_PARENT			Afy::PropertyID(19)			</span><span class="cm">/**&lt; parent (whole) PIN */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_VALUE				Afy::PropertyID(20)			</span><span class="cm">/**&lt; value of the PIN (can be an expression using other properties */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_CREATED			Afy::PropertyID(21)			</span><span class="cm">/**&lt; PIN creation timestamp, immutable */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_CREATEDBY			Afy::PropertyID(22)			</span><span class="cm">/**&lt; identity created the PIN, immutable */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_UPDATED			Afy::PropertyID(23)			</span><span class="cm">/**&lt; timestamp of the latest PIN modification, updated automatically */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_UPDATEDBY			Afy::PropertyID(24)			</span><span class="cm">/**&lt; identity of the latest PIN modification, updated automatically */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ACL				Afy::PropertyID(25)			</span><span class="cm">/**&lt; ACL - can be a collection and contain references to other PINs */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_STAMP				Afy::PropertyID(26)			</span><span class="cm">/**&lt; stamp (unsigned integer) of the latest modification, updated automatically */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_OBJID				Afy::PropertyID(27)			</span><span class="cm">/**&lt; objectID of the class represented by this pin (VT_CLASSID) */</span><span class="cp"></span>
<span class="cp">	#define PROP_SPEC_PREDICATE			Afy::PropertyID(28)			</span><span class="cm">/**&lt; predicate of a class or relations (VT_STMT) */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_COUNT				Afy::PropertyID(29)			</span><span class="cm">/**&lt; number of instances of a given class currently in the store */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_SUBCLASSES		Afy::PropertyID(30)			</span><span class="cm">/**&lt; collection of classes which are specializations of this class */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_SUPERCLASSES		Afy::PropertyID(31)			</span><span class="cm">/**&lt; collection of classes which are abstractions of this class */</span><span class="cp"></span>
<span class="cp">	#define PROP_SPEC_INDEX_INFO		Afy::PropertyID(32)			</span><span class="cm">/**&lt; family index information */</span><span class="cp"></span>
<span class="cp">	#define PROP_SPEC_PROPERTIES		Afy::PropertyID(33)			</span><span class="cm">/**&lt; properties refered by the class */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ONENTER			Afy::PropertyID(34)			</span><span class="cm">/**&lt; PIN entering a class action; flow of control entering a state action */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ONUPDATE			Afy::PropertyID(35)			</span><span class="cm">/**&lt; action on PIN belonging to a class is modified */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ONLEAVE			Afy::PropertyID(36)			</span><span class="cm">/**&lt; PIN leaving a class action; flow of control leaving a state action */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_WINDOW			Afy::PropertyID(37)			</span><span class="cm">/**&lt; stream windowing control (size of class-related window) */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_TRANSITION		Afy::PropertyID(38)			</span><span class="cm">/**&lt; in a workflow: transition(s) to other states */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_EVENT				Afy::PropertyID(39)			</span><span class="cm">/**&lt; event descriptor */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_CONDITION			Afy::PropertyID(40)			</span><span class="cm">/**&lt; condition descriptor in a package; transition condition in a FSM */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ACTION			Afy::PropertyID(41)			</span><span class="cm">/**&lt; timer or listener action; set of actions in a package; transition action */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_REF				Afy::PropertyID(42)			</span><span class="cm">/**&lt; reference field in VT_STRUCT */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_STATE				Afy::PropertyID(43)			</span><span class="cm">/**&lt; FSM instance state */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_INTERVAL			Afy::PropertyID(44)			</span><span class="cm">/**&lt; timer interval or i/o timeout*/</span><span class="cp"></span>
<span class="cp">	#define PROP_SPEC_LOAD				Afy::PropertyID(45)			</span><span class="cm">/**&lt; the name of a library to load */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_SERVICE			Afy::PropertyID(46)			</span><span class="cm">/**&lt; service ID or communication stack descriptor */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_LISTEN			Afy::PropertyID(47)			</span><span class="cm">/**&lt; listener service stack */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ADDRESS			Afy::PropertyID(48)			</span><span class="cm">/**&lt; address for communication PINs (can be reference to other PIN(s)) */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_RESOLVE			Afy::PropertyID(49)			</span><span class="cm">/**&lt; service ID to resolve the address */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_POSITION			Afy::PropertyID(50)			</span><span class="cm">/**&lt; positioning before i/o (seek) */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_REQUEST			Afy::PropertyID(51)			</span><span class="cm">/**&lt; communication request */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_CONTENT			Afy::PropertyID(52)			</span><span class="cm">/**&lt; content of i/o operation, either to be written or read */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_BUFSIZE			Afy::PropertyID(53)			</span><span class="cm">/**&lt; buffer size for buffering services */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_EXCEPTION			Afy::PropertyID(54)			</span><span class="cm">/**&lt; exception code */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_VERSION			Afy::PropertyID(55)			</span><span class="cm">/**&lt; chain of versions */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_WEIGHT			Afy::PropertyID(56)			</span><span class="cm">/**&lt; future implementation */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_SELF				Afy::PropertyID(57)			</span><span class="cm">/**&lt; pseudo-property: the PIN itself */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_PATTERN			Afy::PropertyID(58)			</span><span class="cm">/**&lt; pattern for Regex service */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_PROTOTYPE			Afy::PropertyID(59)			</span><span class="cm">/**&lt; JavaScript-like inheritance or regex prototype*/</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_UNDO				Afy::PropertyID(60)			</span><span class="cm">/**&lt; UNDO operation for communication PINs */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_NAMESPACE			Afy::PropertyID(61)			</span><span class="cm">/**&lt; package namespace prefix */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_SUBPACKAGE		Afy::PropertyID(62)			</span><span class="cm">/**&lt; sub-package(s) of this package */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ENUM				Afy::PropertyID(63)			</span><span class="cm">/**&lt; enumeration string collection */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_IDENTITY			Afy::PropertyID(64)			</span><span class="cm">/**&lt; identity for access to remote store or encryption/decryption in communications */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_CONTENTTYPE		Afy::PropertyID(65)			</span><span class="cm">/**&lt; content type in communication services */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_CONTENTLENGTH		Afy::PropertyID(66)			</span><span class="cm">/**&lt; buffered content length in communication services */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_ACCEPT			Afy::PropertyID(67)			</span><span class="cm">/**&lt; acceptable encodings for communications */</span><span class="cp"></span>
<span class="cp">	#define	PROP_SPEC_TOKEN				Afy::PropertyID(68)			</span><span class="cm">/**&lt; token to match request/response in communications */</span><span class="cp"></span>

<span class="cp">	#define	SERVICE_ENCRYPTION			Afy::URIID(244)				</span><span class="cm">/**&lt; content encryption */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_SERIAL				Afy::URIID(245)				</span><span class="cm">/**&lt; serial port communication */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_BRIDGE				Afy::URIID(246)				</span><span class="cm">/**&lt; bridge between two stores */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_AFFINITY			Afy::URIID(247)				</span><span class="cm">/**&lt; affinity query processor as a service */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_REGEX				Afy::URIID(248)				</span><span class="cm">/**&lt; transformations using regular expressions */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_PATHSQL				Afy::URIID(249)				</span><span class="cm">/**&lt; pathSQL parsing/rendering */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_JSON				Afy::URIID(250)				</span><span class="cm">/**&lt; JSON encoding service */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_PROTOBUF			Afy::URIID(251)				</span><span class="cm">/**&lt; protobuf encoding/decoding service */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_SOCKETS				Afy::URIID(252)				</span><span class="cm">/**&lt; sockets service */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_IO					Afy::URIID(253)				</span><span class="cm">/**&lt; OS i/o service */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_REMOTE				Afy::URIID(254)				</span><span class="cm">/**&lt; remote content reading service (not built-in) */</span><span class="cp"></span>
<span class="cp">	#define	SERVICE_REPLICATION			Afy::URIID(255)				</span><span class="cm">/**&lt; replication service (not built-in) */</span><span class="cp"></span>

<span class="cp">	#define	MIN_BUILTIN_SERVICE			Afy::URIID(216)</span>
<span class="cp">	#define	MAX_BUILTIN_URIID			Afy::URIID(255)</span>
<span class="cp">	#define	MAX_BUILTIN_CLASSID			CLASS_OF_HANDLERS</span>
<span class="cp">	#define	MAX_BUILTIN_PROPID			PROP_SPEC_STATE</span>
<span class="cp">	</span>
<span class="cp">	#define	PROP_SPEC_ANY				(~Afy::PropertyID(0))			</span><span class="cm">/**&lt; used in queries, matches any property */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * special collection element IDs</span>
<span class="cm">	 * @see Value::eid</span>
<span class="cm">	 */</span>
<span class="cp">	#define	STORE_COLLECTION_ID			(~Afy::ElementID(0))		</span><span class="cm">/**&lt; Singleton value or operation applied to the whole collection */</span><span class="cp"></span>
<span class="cp">	#define	STORE_LAST_ELEMENT			(~Afy::ElementID(1))		</span><span class="cm">/**&lt; Last element of a collection */</span><span class="cp"></span>
<span class="cp">	#define	STORE_FIRST_ELEMENT			(~Afy::ElementID(2))		</span><span class="cm">/**&lt; First element of a collection */</span><span class="cp"></span>
<span class="cp">	#define	STORE_SUM_COLLECTION		(~Afy::ElementID(3))		</span><span class="cm">/**&lt; IStmt: replace collection with the sum of its elements */</span><span class="cp"></span>
<span class="cp">	#define	STORE_AVG_COLLECTION		(~Afy::ElementID(4))		</span><span class="cm">/**&lt; IStmt: replace collection with the average of its elements */</span><span class="cp"></span>
<span class="cp">	#define	STORE_CONCAT_COLLECTION		(~Afy::ElementID(5))		</span><span class="cm">/**&lt; IStmt: replace collection with the concatenation of its elements */</span><span class="cp"></span>
<span class="cp">	#define	STORE_MIN_ELEMENT			(~Afy::ElementID(6))		</span><span class="cm">/**&lt; IStmt: replace collection with the minimum of its elements */</span><span class="cp"></span>
<span class="cp">	#define	STORE_MAX_ELEMENT			(~Afy::ElementID(7))		</span><span class="cm">/**&lt; IStmt: replace collection with the maximum of its elements */</span><span class="cp"></span>
<span class="cp">	#define	STORE_SOME_ELEMENT			(~Afy::ElementID(8))		</span><span class="cm">/**&lt; IStmt: existential quantifier for the collection */</span><span class="cp"></span>
<span class="cp">	#define	STORE_ALL_ELEMENTS			(~Afy::ElementID(9))		</span><span class="cm">/**&lt; IStmt: &#39;for all&#39; quantifier */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * PIN create/commit/modify/delete, IStmt execute mode flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define MODE_NORET					0x00010000	</span><span class="cm">/**&lt; in ServiceCtx::createPIN() - the PIN is not returned by the service, rather referred by another PIN */</span><span class="cp"></span>
<span class="cp">	#define MODE_NO_EID					0x00010000	</span><span class="cm">/**&lt; in modify() - don&#39;t update &quot;eid&quot; field of Value structure */</span><span class="cp"></span>
<span class="cp">	#define	MODE_FOR_UPDATE				0x00020000	</span><span class="cm">/**&lt; in IStmt::execute(): lock pins for update while reading them */</span><span class="cp"></span>
<span class="cp">	#define	MODE_PERSISTENT				0x00040000	</span><span class="cm">/**&lt; used in PIN::clone(), ISession::createPIN() to immediately commit new pin */</span><span class="cp"></span>
<span class="cp">	#define	MODE_PURGE					0x00040000	</span><span class="cm">/**&lt; in deletePINs(): purge pins rather than just delete */</span><span class="cp"></span>
<span class="cp">	#define	MODE_ALL					0x00040000	</span><span class="cm">/**&lt; for STMT_COMMIT, STMT_ROLLBACK - commit/rollback all nested transactions or persist all transient pins */</span><span class="cp"></span>
<span class="cp">	#define	MODE_READONLY				0x00040000	</span><span class="cm">/**&lt; for STMT_START_TX - start r/o transaction */</span><span class="cp"></span>
<span class="cp">	#define	MODE_COPY_VALUES			0x00080000	</span><span class="cm">/**&lt; used in createPIN() and IStmt::execute() to copy Values (parameters, query expressions, etc.) passed rather than assume ownership */</span><span class="cp"></span>
<span class="cp">	#define	MODE_FORCE_EIDS				0x00100000	</span><span class="cm">/**&lt; used only in replication */</span><span class="cp"></span>
<span class="cp">	#define	MODE_PART					0x00100000	</span><span class="cm">/**&lt; in nested insert: create a part */</span><span class="cp"></span>
<span class="cp">	#define	MODE_TEMP_ID				0x00200000	</span><span class="cm">/**&lt; when a PIN is persisted: create a pin with a temporary (reusable, non-unique) id */</span><span class="cp"></span>
<span class="cp">	#define	MODE_CHECK_STAMP			0x00200000	</span><span class="cm">/**&lt; forces stamp check before modification; if stamp changed the op is aborted and RC_REPEAT is returned */</span><span class="cp"></span>
<span class="cp">	#define	MODE_HOLD_RESULT			0x00200000	</span><span class="cm">/**&lt; for IStmt::execute(): don&#39;t close result set on transaction commit/rollback */</span><span class="cp"></span>
<span class="cp">	#define	MODE_ALL_WORDS				0x00400000	</span><span class="cm">/**&lt; all words must be present in FT condition */</span><span class="cp"></span>
<span class="cp">	#define	MODE_SAME					0x00400000	</span><span class="cm">/**&lt; IBatch::createPIN(): the structure of the pin is the same as previous */</span><span class="cp"></span>
<span class="cp">	#define	MODE_DELETED				0x00800000	</span><span class="cm">/**&lt; for query: return only (soft)deleted pins */</span><span class="cp"></span>
<span class="cp">	#define	MODE_RAW					0x01000000	</span><span class="cm">/**&lt; SELECT/UPDATE: return PIN properties as they are stored, no calculation/communication */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * PIN creation flags (starts with 0x40000000 for compatibility with protobuf)</span>
<span class="cm">	 */</span>
<span class="cp">	#define	PIN_NO_REPLICATION			0x40000000	</span><span class="cm">/**&lt; marks a PIN as one which shouldn&#39;t be replicated (set only when the PIN is committed) */</span><span class="cp"></span>
<span class="cp">	#define	PIN_NOTIFY					0x20000000	</span><span class="cm">/**&lt; PIN generates notifications when committed, modified or deleted */</span><span class="cp"></span>
<span class="cp">	#define	PIN_REPLICATED				0x10000000	</span><span class="cm">/**&lt; PIN is replicated to another store or is a replica */</span><span class="cp"></span>
<span class="cp">	#define	PIN_HIDDEN					0x08000000	</span><span class="cm">/**&lt; special PIN - totally hidden from search/replication - accessible only through its PID */</span><span class="cp"></span>
<span class="cp">	#define	PIN_PERSISTENT				0x04000000	</span><span class="cm">/**&lt; PIN is committed to persistent storage */</span><span class="cp"></span>
<span class="cp">	#define	PIN_TRANSIENT				0x02000000	</span><span class="cm">/**&lt; PIN used as a message, not indexed, not persisted */</span><span class="cp"></span>
<span class="cp">	#define	PIN_IMMUTABLE				0x01000000	</span><span class="cm">/**&lt; immutable PIN (e.g. external event) */</span><span class="cp"></span>
<span class="cp">	#define	PIN_DELETED					0x00800000	</span><span class="cm">/**&lt; PIN has been soft-deleted */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * PIN metatype flags</span>
<span class="cm">	 * @see PIN::getMetaType()</span>
<span class="cm">	 */</span>
<span class="cp">	#define	PMT_NAMED					0x0001		</span><span class="cm">/**&lt; PIN with afy:objectID */</span><span class="cp"></span>
<span class="cp">	#define	PMT_CLASS					0x0002		</span><span class="cm">/**&lt; class PIN */</span><span class="cp"></span>
<span class="cp">	#define	PMT_TIMER					0x0004		</span><span class="cm">/**&lt; timer PIN */</span><span class="cp"></span>
<span class="cp">	#define	PMT_LISTENER				0x0008		</span><span class="cm">/**&lt; socket listener PIN */</span><span class="cp"></span>
<span class="cp">	#define	PMT_PACKAGE					0x0010		</span><span class="cm">/**&lt; package PIN */</span><span class="cp"></span>
<span class="cp">	#define	PMT_LOADER					0x0020		</span><span class="cm">/**&lt; service descriptor for automatic load */</span><span class="cp"></span>
<span class="cp">	#define	PMT_ENUM					0x0040		</span><span class="cm">/**&lt; enumeration PIN */</span><span class="cp"></span>
<span class="cp">	#define	PMT_COMM					0x0080		</span><span class="cm">/**&lt; communication PIN */</span><span class="cp"></span>
<span class="cp">	#define	PMT_FSMCTX					0x0100		</span><span class="cm">/**&lt; FSM invocation context */</span><span class="cp"></span>
<span class="cp">	#define	PMT_FSM						0x0200		</span><span class="cm">/**&lt; FSM start node */</span><span class="cp"></span>
<span class="cp">	#define	PMT_HANDLER					0x0400		</span><span class="cm">/**&lt; event handler */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * meta-properties</span>
<span class="cm">	 * @see Value::meta</span>
<span class="cm">	 */</span>
<span class="cp">	#define	META_PROP_PART				0x80		</span><span class="cm">/**&lt; property is a reference to a PIN which is a part of this one */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_FTINDEX			0x80		</span><span class="cm">/**&lt; this property (VT_STRING) to be FT indexed */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_SSTORAGE			0x40		</span><span class="cm">/**&lt; store this property separately from the pin body (for string, stream and compound property types) */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_UNSIGNED			0x40		</span><span class="cm">/**&lt; unsigned right shift (&gt;&gt;&gt;=) for UPDATE */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_INMEM				0x20		</span><span class="cm">/**&lt; property is not persisted */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_INDEXED			0x10		</span><span class="cm">/**&lt; PROP_SPEC_PREDICATE: a class with indexed membership */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_SYNC				0x10		</span><span class="cm">/**&lt; PROP_SPEC_SERVICE: force blocking read/write operations, PROP_SPEC_STATE, PROP_SPEC_ACTION: synchronous execution */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_ASYNC				0x08		</span><span class="cm">/**&lt; PROP_SPEC_SERVICE: force non-blocking read/write operations, PROP_SPEC_STATE, PROP_SPEC_ACTION: asynchronous execution */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_KEEPALIVE			0x08		</span><span class="cm">/**&lt; PROP_SPEC_ADDRESS: cache connection/device handle */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_CREATE			0x04		</span><span class="cm">/**&lt; PROP_SPEC_ADDRESS: CREATE flag when openning communication channel */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_LEAVE				0x04		</span><span class="cm">/**&lt; PROP_SPEC_ACTION:  call on leaving class */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_WRITE				0x02		</span><span class="cm">/**&lt; write premission in ACLs and device communication */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_UPDATE			0x02		</span><span class="cm">/**&lt; PROP_SPEC_ACTION: call on update in a class */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_SEEK_END			0x02		</span><span class="cm">/**&lt; PROP_SPEC_POSITION: seek from the end */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_READ				0x01		</span><span class="cm">/**&lt; read premission in ACLs and device communication, force to IPv4 in sockets */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_ENTER				0x01		</span><span class="cm">/**&lt; PROP_SPEC_ACTION: call on entering a class */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_OPTIONAL			0x01		</span><span class="cm">/**&lt; PROP_SPEC_LOAD: don&#39;t fail if cannot load */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_SEEK_CUR			0x01		</span><span class="cm">/**&lt; PROP_SPEC_POSITION: seek from current position */</span><span class="cp"></span>
<span class="cp">	#define	META_PROP_ALT				0x01		</span><span class="cm">/**&lt; PROP_SPEC_SERVICE: alternative service format (e.g. UDP for srv:sockets) */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * class-related notification flags</span>
<span class="cm">	 * @see ISession::setNotification()</span>
<span class="cm">	 */</span>
<span class="cp">	#define CLASS_NOTIFY_JOIN			0x0001		</span><span class="cm">/**&lt; a pin becomes a member of the class */</span><span class="cp"></span>
<span class="cp">	#define CLASS_NOTIFY_LEAVE			0x0002		</span><span class="cm">/**&lt; a pin stops to be a member of the class */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_NOTIFY_CHANGE			0x0004		</span><span class="cm">/**&lt; a member of the class was changed */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_NOTIFY_DELETE			0x0008		</span><span class="cm">/**&lt; a pin - a member of the class - was deleted */</span><span class="cp"></span>
<span class="cp">	#define	CLASS_NOTIFY_NEW			0x0010		</span><span class="cm">/**&lt; a new pin was created as a member of the class */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * types of transactions</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">TX_TYPE</span>
	<span class="p">{</span>
		<span class="n">TXT_READONLY</span><span class="p">,</span> <span class="n">TXT_READWRITE</span><span class="p">,</span> <span class="n">TXT_MODIFYCLASS</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * transaction isolation levels</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">TXI_LEVEL</span>
	<span class="p">{</span>
		<span class="n">TXI_DEFAULT</span><span class="p">,</span>
		<span class="n">TXI_READ_UNCOMMITTED</span><span class="p">,</span>
		<span class="n">TXI_READ_COMMITTED</span><span class="p">,</span>
		<span class="n">TXI_REPEATABLE_READ</span><span class="p">,</span>
		<span class="n">TXI_SERIALIZABLE</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * toString() functions control flags</span>
<span class="cm">	 * @see IStmt::toString(), IExpr::toString(), IExprNode::toString()</span>
<span class="cm">	 */</span>
<span class="cp">	#define	TOS_PROLOGUE				0x40000000</span>
<span class="cp">	#define	TOS_NO_QNAMES				0x80000000</span>

	<span class="cm">/**</span>
<span class="cm">	 * interface control flags</span>
<span class="cm">	 * @see ISession::setInterfaceMode()</span>
<span class="cm">	 */</span>
<span class="cp">	#define	ITF_DEFAULT_REPLICATION		0x0001		</span><span class="cm">/**&lt; by default all new pins marked as replicated */</span><span class="cp"></span>
<span class="cp">	#define	ITF_REPLICATION				0x0002		</span><span class="cm">/**&lt; replication session */</span><span class="cp"></span>
<span class="cp">	#define	ITF_CATCHUP					0x0004		</span><span class="cm">/**&lt; catchup session */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * Trace control flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define	TRACE_SESSION_QUERIES		0x0001		</span><span class="cm">/**&lt; trace all queries executed within this session */</span><span class="cp"></span>
<span class="cp">	#define TRACE_STORE_BUFFERS			0x0002		</span><span class="cm">/**&lt; not implemented yet */</span><span class="cp"></span>
<span class="cp">	#define TRACE_STORE_IO				0x0004		</span><span class="cm">/**&lt; not implemented yet */</span><span class="cp"></span>
<span class="cp">	#define	TRACE_EXEC_PLAN				0x0008		</span><span class="cm">/**&lt; output execution plan for all queries in this session */</span><span class="cp"></span>
<span class="cp">	#define	TRACE_ACTIONS				0x0010		</span><span class="cm">/**&lt; trace class action invocation */</span><span class="cp"></span>
<span class="cp">	#define	TRACE_TIMERS				0x0020		</span><span class="cm">/**&lt; trace timer events */</span><span class="cp"></span>
<span class="cp">	#define	TRACE_COMMS					0x0040		</span><span class="cm">/**&lt; trace communication stacks */</span><span class="cp"></span>
<span class="cp">	#define	TRACE_FSMS					0x0080		</span><span class="cm">/**&lt; trace FSM state transitions */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * memory allocator interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">IMemAlloc</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="o">*</span><span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																<span class="cm">/**&lt; allocate a memory block */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="o">*</span><span class="n">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="kt">size_t</span><span class="p">,</span><span class="kt">size_t</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; increase or decrease block size */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; free block */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * External timestamp (VT_DATETIME) representation</span>
<span class="cm">	 * @see ISession::convDateTime()</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">DateTime</span>
	<span class="p">{</span>
		<span class="kt">uint16_t</span>	<span class="n">year</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">month</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">dayOfWeek</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">day</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">hour</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">minute</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">second</span><span class="p">;</span>
		<span class="kt">uint32_t</span>	<span class="n">microseconds</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Enumeration of subtypes for VT_CURRENT</span>
<span class="cm">	 * @see Value</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">CurrentValue</span>
	<span class="p">{</span>
		<span class="n">CVT_TIMESTAMP</span><span class="p">,</span> <span class="n">CVT_USER</span><span class="p">,</span> <span class="n">CVT_STORE</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * OP_EXTRACT modes</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">ExtractType</span>
	<span class="p">{</span>
		<span class="n">EY_FRACTIONAL</span><span class="p">,</span> <span class="n">EY_SECOND</span><span class="p">,</span> <span class="n">EY_MINUTE</span><span class="p">,</span> <span class="n">EY_HOUR</span><span class="p">,</span> <span class="n">EY_DAY</span><span class="p">,</span> <span class="n">EY_WDAY</span><span class="p">,</span> <span class="n">EY_MONTH</span><span class="p">,</span> <span class="n">EY_YEAR</span><span class="p">,</span>
		<span class="n">EY_IDENTITY</span><span class="p">,</span> <span class="n">EY_STOREID</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Supported value types</span>
<span class="cm">	 * @see Value::type</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">ValueType</span> 
	<span class="p">{</span>
		<span class="n">VT_ERROR</span><span class="p">,</span><span class="n">VT_ANY</span><span class="o">=</span><span class="n">VT_ERROR</span><span class="p">,</span>		<span class="cm">/**&lt; used to report errors, non-existant properties; VT_ANY designates no conversion in transforms */</span>

		<span class="n">VT_INT</span><span class="p">,</span>							<span class="cm">/**&lt; 32-bit signed integer */</span>
		<span class="n">VT_UINT</span><span class="p">,</span>						<span class="cm">/**&lt; 32-bit unsigned integer */</span>
		<span class="n">VT_INT64</span><span class="p">,</span>						<span class="cm">/**&lt; 64-bit signed integer */</span>
		<span class="n">VT_UINT64</span><span class="p">,</span>						<span class="cm">/**&lt; 64-bit unsigned integer */</span>
		<span class="n">VT_FLOAT</span><span class="p">,</span>						<span class="cm">/**&lt; 32-bit floating number */</span>
		<span class="n">VT_DOUBLE</span><span class="p">,</span>						<span class="cm">/**&lt; 64-bit floating number */</span>

		<span class="n">VT_BOOL</span><span class="p">,</span>						<span class="cm">/**&lt; boolean value (true, false) */</span>

		<span class="n">VT_DATETIME</span><span class="p">,</span>					<span class="cm">/**&lt; timestamp stored as a 64-bit number of microseconds since fixed date */</span>
		<span class="n">VT_INTERVAL</span><span class="p">,</span>					<span class="cm">/**&lt; time interval stored as a 64-bit signed number of microseconds */</span>

		<span class="n">VT_URIID</span><span class="p">,</span>						<span class="cm">/**&lt; URIID */</span>
		<span class="n">VT_IDENTITY</span><span class="p">,</span>					<span class="cm">/**&lt; IdentityID */</span>

		<span class="n">VT_ENUM</span><span class="p">,</span>						<span class="cm">/**&lt; enumeration element */</span>

		<span class="n">VT_STRING</span><span class="p">,</span>						<span class="cm">/**&lt; zero-ended string UTF-8*/</span>
		<span class="n">VT_BSTR</span><span class="p">,</span>						<span class="cm">/**&lt; binary string */</span>

		<span class="n">VT_REF</span><span class="p">,</span>							<span class="cm">/**&lt; a reference to another IPIN */</span>
		<span class="n">VT_REFID</span><span class="p">,</span>						<span class="cm">/**&lt; a reference to another PIN by its PID */</span>
		<span class="n">VT_REFPROP</span><span class="p">,</span>						<span class="cm">/**&lt; a reference to a value (property of this or another PIN) by IPIN &amp; PropertyID */</span>
		<span class="n">VT_REFIDPROP</span><span class="p">,</span>					<span class="cm">/**&lt; a reference to a value (property of this or another PIN) by its PID/PropertyID */</span>
		<span class="n">VT_REFELT</span><span class="p">,</span>						<span class="cm">/**&lt; a reference to a collection element by its IPIN/PropertyID/ElementID */</span>
		<span class="n">VT_REFIDELT</span><span class="p">,</span>					<span class="cm">/**&lt; a reference to a collection element by its PID/PropertyID/ElementID */</span>

		<span class="n">VT_EXPR</span><span class="p">,</span>						<span class="cm">/**&lt; IExpr: stored expression */</span>
		<span class="n">VT_STMT</span><span class="p">,</span>						<span class="cm">/**&lt; IStmt: stored query object */</span>

		<span class="n">VT_COLLECTION</span><span class="p">,</span>					<span class="cm">/**&lt; collection property */</span>
		<span class="n">VT_STRUCT</span><span class="p">,</span>						<span class="cm">/**&lt; composite value */</span>
		<span class="n">VT_MAP</span><span class="p">,</span>							<span class="cm">/**&lt; reserved for future use */</span>
		<span class="n">VT_RANGE</span><span class="p">,</span>						<span class="cm">/**&lt; range of values for OP_IN, equivalent to VT_COLLECTION with length = 2 */</span>
		<span class="n">VT_ARRAY</span><span class="p">,</span>						<span class="cm">/**&lt; an array (see FixedArray) */</span>
		<span class="n">VT_STREAM</span><span class="p">,</span>						<span class="cm">/**&lt; IStream interface */</span>
		<span class="n">VT_CURRENT</span><span class="p">,</span>						<span class="cm">/**&lt; current moment in time, current user, etc. */</span>

		<span class="n">VT_VARREF</span><span class="p">,</span>						<span class="cm">/**&lt; statement: var ref  (cannot be persisted as a property value) */</span>
		<span class="n">VT_EXPRTREE</span><span class="p">,</span>					<span class="cm">/**&lt; sub-expression reference for statement conditions (cannot be persisted as a property value) */</span>

		<span class="n">VT_ALL</span>
	<span class="p">};</span>

	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isRef</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">vt</span><span class="o">-</span><span class="n">VT_REF</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">VT_REFIDELT</span><span class="o">-</span><span class="n">VT_REF</span><span class="p">);}</span>
	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isInteger</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">vt</span><span class="o">-</span><span class="n">VT_INT</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">VT_UINT64</span><span class="o">-</span><span class="n">VT_INT</span><span class="p">);}</span>
	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isNumeric</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">vt</span><span class="o">-</span><span class="n">VT_INT</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">VT_DOUBLE</span><span class="o">-</span><span class="n">VT_INT</span><span class="p">);}</span>
	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isString</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">vt</span><span class="o">-</span><span class="n">VT_STRING</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">VT_BSTR</span><span class="o">-</span><span class="n">VT_STRING</span><span class="p">);}</span>
	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isCollection</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">vt</span><span class="o">==</span><span class="n">VT_COLLECTION</span><span class="p">;}</span>
	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isComposite</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">vt</span><span class="o">-</span><span class="n">VT_COLLECTION</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">VT_ARRAY</span><span class="o">-</span><span class="n">VT_COLLECTION</span><span class="p">);}</span>
	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isSimpleConst</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">vt</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint8_t</span><span class="p">(</span><span class="n">vt</span><span class="o">-</span><span class="n">VT_INT</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">VT_BSTR</span><span class="o">-</span><span class="n">VT_INT</span><span class="p">);}</span>

	<span class="cm">/**</span>
<span class="cm">	 * Supported operations for expressions and property modifications</span>
<span class="cm">	 * @see Value::op</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">ExprOp</span>
	<span class="p">{</span>
		<span class="n">OP_SET</span><span class="p">,</span>						<span class="cm">/**&lt; used to add a new property or to set a new value for old property */</span>
		<span class="n">OP_ADD</span><span class="p">,</span>						<span class="cm">/**&lt; adds a new collection element for existing property (doesn&#39;t have to be a collection) */</span>
		<span class="n">OP_ADD_BEFORE</span><span class="p">,</span>				<span class="cm">/**&lt; add a new collection element before existing element (OP_ADD inserts after) */</span>
		<span class="n">OP_MOVE</span><span class="p">,</span>					<span class="cm">/**&lt; move a collection element to new position */</span>
		<span class="n">OP_MOVE_BEFORE</span><span class="p">,</span>				<span class="cm">/**&lt; move a collection element to new position (before specific element) */</span>			
		<span class="n">OP_DELETE</span><span class="p">,</span>					<span class="cm">/**&lt; deletes the whole property or an element of a compound property */</span>
		<span class="n">OP_EDIT</span><span class="p">,</span>					<span class="cm">/**&lt; string editing operation (VT_STRING/VT_BSTR) ot bit edit (VT_INT/VT_UINT/VT_INT64/VT_UINT64/VT_BSTR) */</span>
		<span class="n">OP_RENAME</span><span class="p">,</span>					<span class="cm">/**&lt; rename a property, i.e. replace one PropertyID with another one */</span>
		<span class="n">OP_FIRST_EXPR</span><span class="p">,</span>				<span class="cm">/**&lt; start of op codes which can be used in expressions */</span>
		<span class="n">OP_PLUS</span><span class="o">=</span><span class="n">OP_FIRST_EXPR</span><span class="p">,</span>		<span class="cm">/**&lt; binary &#39;+&#39; or &#39;+=&#39; */</span>
		<span class="n">OP_MINUS</span><span class="p">,</span>					<span class="cm">/**&lt; binary &#39;-&#39; or &#39;-=&#39; */</span>
		<span class="n">OP_MUL</span><span class="p">,</span>						<span class="cm">/**&lt; &#39;*&#39; or &#39;*=&#39; */</span>
		<span class="n">OP_DIV</span><span class="p">,</span>						<span class="cm">/**&lt; &#39;/&#39; or &#39;/=&#39; */</span>
		<span class="n">OP_MOD</span><span class="p">,</span>						<span class="cm">/**&lt; &#39;%&#39; or &#39;%=&#39; */</span>
		<span class="n">OP_NEG</span><span class="p">,</span>						<span class="cm">/**&lt; unary &#39;-&#39;*/</span>
		<span class="n">OP_NOT</span><span class="p">,</span>						<span class="cm">/**&lt; bitwise not, &#39;~&#39; */</span>
		<span class="n">OP_AND</span><span class="p">,</span>						<span class="cm">/**&lt; bitwise &#39;&amp;&#39; or &#39;&amp;=&#39; */</span>
		<span class="n">OP_OR</span><span class="p">,</span>						<span class="cm">/**&lt; bitwise &#39;|&#39; or &#39;|=&#39; */</span>
		<span class="n">OP_XOR</span><span class="p">,</span>						<span class="cm">/**&lt; bitwise &#39;^&#39; or &#39;^=&#39; */</span>
		<span class="n">OP_LSHIFT</span><span class="p">,</span>					<span class="cm">/**&lt; bitwise &#39;&lt;&lt;&#39; or &#39;&lt;&lt;=&#39; */</span>
		<span class="n">OP_RSHIFT</span><span class="p">,</span>					<span class="cm">/**&lt; bitwise &#39;&gt;&gt;&#39; or &#39;&gt;&gt;=&#39;, can be unsigned if UNSIGNED_OP (see below) flag is set */</span>
		<span class="n">OP_SETBIT</span><span class="p">,</span>					<span class="cm">/**&lt; set bit in a binary string by bit number */</span>
		<span class="n">OP_RESETBIT</span><span class="p">,</span>				<span class="cm">/**&lt; reset bit in a binary string by bit number */</span>
		<span class="n">OP_MIN</span><span class="p">,</span>						<span class="cm">/**&lt; minimum of 2 or more values, minimum of collection, array */</span>
		<span class="n">OP_MAX</span><span class="p">,</span>						<span class="cm">/**&lt; maximum of 2 or more values, maximum of collection, array */</span>
		<span class="n">OP_ARGMIN</span><span class="p">,</span>					<span class="cm">/**&lt; the index of the argument or array element, or the reference to collection elemnet, which is minimal (minimizes an expression) */</span>
		<span class="n">OP_ARGMAX</span><span class="p">,</span>					<span class="cm">/**&lt; the index of the argument or array element, or the reference to collection elemnet, which is maximal (maximizes an expression) */</span>
		<span class="n">OP_ABS</span><span class="p">,</span>						<span class="cm">/**&lt; absolute value */</span>
		<span class="n">OP_LN</span><span class="p">,</span>						<span class="cm">/**&lt; natural logarithm */</span>
		<span class="n">OP_EXP</span><span class="p">,</span>						<span class="cm">/**&lt; exponent */</span>
		<span class="n">OP_POW</span><span class="p">,</span>						<span class="cm">/**&lt; power */</span>
		<span class="n">OP_SQRT</span><span class="p">,</span>					<span class="cm">/**&lt; square root */</span>
		<span class="n">OP_SIN</span><span class="p">,</span>						<span class="cm">/**&lt; sine */</span>
		<span class="n">OP_COS</span><span class="p">,</span>						<span class="cm">/**&lt; cosine */</span>
		<span class="n">OP_TAN</span><span class="p">,</span>						<span class="cm">/**&lt; tangent */</span>
		<span class="n">OP_ASIN</span><span class="p">,</span>					<span class="cm">/**&lt; arcsine */</span>
		<span class="n">OP_ACOS</span><span class="p">,</span>					<span class="cm">/**&lt; arccosine */</span>
		<span class="n">OP_ATAN</span><span class="p">,</span>					<span class="cm">/**&lt; arctangent */</span>
		<span class="n">OP_NORM</span><span class="p">,</span>					<span class="cm">/**&lt; vector norm for 1-dim VT_ARRAY */</span>
		<span class="n">OP_TRACE</span><span class="p">,</span>					<span class="cm">/**&lt; matrix trace for 2-dim VT_ARRAY */</span>
		<span class="n">OP_INV</span><span class="p">,</span>						<span class="cm">/**&lt; matrix inverse for 2-dim VT_ARRAY */</span>
		<span class="n">OP_DET</span><span class="p">,</span>						<span class="cm">/**&lt; matrix determinant for 2-dim VT_ARRAY */</span>
		<span class="n">OP_RANK</span><span class="p">,</span>					<span class="cm">/**&lt; matrix rank for 2-dim VT_ARRAY */</span>
		<span class="n">OP_TRANSPOSE</span><span class="p">,</span>				<span class="cm">/**&lt; transpose of a matrix */</span>
		<span class="n">OP_FLOOR</span><span class="p">,</span>					<span class="cm">/**&lt; floor */</span>
		<span class="n">OP_CEIL</span><span class="p">,</span>					<span class="cm">/**&lt; ceil */</span>
		<span class="n">OP_CONCAT</span><span class="p">,</span>					<span class="cm">/**&lt; concatenate strings */</span>
		<span class="n">OP_LOWER</span><span class="p">,</span>					<span class="cm">/**&lt; convert UTF-8 string to lower case */</span>
		<span class="n">OP_UPPER</span><span class="p">,</span>					<span class="cm">/**&lt; convert UTF-8 string to upper case */</span>
		<span class="n">OP_TONUM</span><span class="p">,</span>					<span class="cm">/**&lt; convert to number */</span>
		<span class="n">OP_TOINUM</span><span class="p">,</span>					<span class="cm">/**&lt; convert to integer number */</span>
		<span class="n">OP_CAST</span><span class="p">,</span>					<span class="cm">/**&lt; convert to arbitrary type, convert measurment units */</span>
		<span class="n">OP_LAST_MODOP</span><span class="o">=</span><span class="n">OP_CAST</span><span class="p">,</span>
		<span class="n">OP_RANGE</span><span class="p">,</span>					<span class="cm">/**&lt; VT_RANGE constructor, returns a range defined by its 2 arguments */</span>
		<span class="n">OP_COLLECTION</span><span class="p">,</span>				<span class="cm">/**&lt; VT_COLLECTION constructor, returns a collection consisting of arguments passed */</span>
		<span class="n">OP_STRUCT</span><span class="p">,</span>					<span class="cm">/**&lt; VT_STRUCT constructor, returns a structure consisting of passed values, Value::property must be set */</span>
		<span class="n">OP_PIN</span><span class="p">,</span>						<span class="cm">/**&lt; same as OP_STRUCT, but returns a PIN (VT_REF) */</span>
		<span class="n">OP_ARRAY</span><span class="p">,</span>					<span class="cm">/**&lt; VT_ARRAY constructor */</span>
		<span class="n">OP_ELEMENT</span><span class="p">,</span>					<span class="cm">/**&lt; extract collection, array, map element or structure field by calculated index */</span>
		<span class="n">OP_COUNT</span><span class="p">,</span>					<span class="cm">/**&lt; number of elements in a collection, or number of PINs in the result set of a query or in a group */</span>
		<span class="n">OP_LENGTH</span><span class="p">,</span>					<span class="cm">/**&lt; string length in bytes or number elements in a collection */</span>
		<span class="n">OP_POSITION</span><span class="p">,</span>				<span class="cm">/**&lt; position of a substring in a string */</span>
		<span class="n">OP_SUBSTR</span><span class="p">,</span>					<span class="cm">/**&lt; extract substring from a string */</span>
		<span class="n">OP_REPLACE</span><span class="p">,</span>					<span class="cm">/**&lt; replace substring in a string with another string */</span>
		<span class="n">OP_PAD</span><span class="p">,</span>						<span class="cm">/**&lt; pad a string with a given character or a string of characters */</span>
		<span class="n">OP_TRIM</span><span class="p">,</span>					<span class="cm">/**&lt; trim leading, trailing characters, or both */</span>
		<span class="n">OP_SUM</span><span class="p">,</span>						<span class="cm">/**&lt; aggregate: sum of collection values, sum of values in a group */</span>
		<span class="n">OP_AVG</span><span class="p">,</span>						<span class="cm">/**&lt; aggregate: average of collection values, average of values in a group */</span>
		<span class="n">OP_VAR_POP</span><span class="p">,</span>					<span class="cm">/**&lt; aggregate: variance of collection values, variance of values in a group */</span>
		<span class="n">OP_VAR_SAMP</span><span class="p">,</span>				<span class="cm">/**&lt; aggregate: variance of collection values, variance of values in a group */</span>
		<span class="n">OP_STDDEV_POP</span><span class="p">,</span>				<span class="cm">/**&lt; aggregate: standard deviation of collection values, standard deviation of values in a group */</span>
		<span class="n">OP_STDDEV_SAMP</span><span class="p">,</span>				<span class="cm">/**&lt; aggregate: standard deviation of collection values, standard deviation of values in a group */</span>
		<span class="n">OP_HISTOGRAM</span><span class="p">,</span>				<span class="cm">/**&lt; aggregate: histogram of collection values, histogram of values in a group */</span>
		<span class="n">OP_COALESCE</span><span class="p">,</span>				<span class="cm">/**&lt; not implemented yet */</span>
		<span class="n">OP_MEMBERSHIP</span><span class="p">,</span>				<span class="cm">/**&lt; returns a collection of ClassIDs of classes a pin is a member of */</span>
		<span class="n">OP_PATH</span><span class="p">,</span>					<span class="cm">/**&lt; segment of a path expression */</span>
		<span class="n">OP_FIRST_BOOLEAN</span><span class="p">,</span>			<span class="cm">/**&lt; start of Boolean predicates */</span>
		<span class="n">OP_EQ</span><span class="o">=</span><span class="n">OP_FIRST_BOOLEAN</span><span class="p">,</span>		<span class="cm">/**&lt; equal */</span>
		<span class="n">OP_NE</span><span class="p">,</span>						<span class="cm">/**&lt; not equal */</span>
		<span class="n">OP_LT</span><span class="p">,</span>						<span class="cm">/**&lt; less than */</span>
		<span class="n">OP_LE</span><span class="p">,</span>						<span class="cm">/**&lt; less or equal than */</span>
		<span class="n">OP_GT</span><span class="p">,</span>						<span class="cm">/**&lt; greater than */</span>
		<span class="n">OP_GE</span><span class="p">,</span>						<span class="cm">/**&lt; greater or equal than */</span>
		<span class="n">OP_IN</span><span class="p">,</span>						<span class="cm">/**&lt; value is in a collection or result set, value is in range, pin is in result set, etc. */</span>
		<span class="n">OP_BEGINS</span><span class="p">,</span>					<span class="cm">/**&lt; string begins with the prefix */</span>
		<span class="n">OP_CONTAINS</span><span class="p">,</span>				<span class="cm">/**&lt; string contains substring */</span>
		<span class="n">OP_ENDS</span><span class="p">,</span>					<span class="cm">/**&lt; string ends with the suffix */</span>
		<span class="n">OP_TESTBIT</span><span class="p">,</span>					<span class="cm">/**&lt; test bit in a binary string */</span>
		<span class="n">OP_SIMILAR</span><span class="p">,</span>					<span class="cm">/**&lt; regular expression match */</span>
		<span class="n">OP_EXISTS</span><span class="p">,</span>					<span class="cm">/**&lt; property exists in PIN, i.e. IS NOT NULL */</span>
		<span class="n">OP_ISLOCAL</span><span class="p">,</span>					<span class="cm">/**&lt; PIN is local, i.e. not replicated, not read-only remote cached */</span>
		<span class="n">OP_IS_A</span><span class="p">,</span>					<span class="cm">/**&lt; PIN is a member of a class or one in a collection of classes */</span>
		<span class="n">OP_LAND</span><span class="p">,</span>					<span class="cm">/**&lt; logical AND */</span>
		<span class="n">OP_LOR</span><span class="p">,</span>						<span class="cm">/**&lt; logical OR */</span>
		<span class="n">OP_LNOT</span><span class="p">,</span>					<span class="cm">/**&lt; logical NOT */</span>
		<span class="n">OP_LAST_BOOLEAN</span><span class="o">=</span><span class="n">OP_LNOT</span><span class="p">,</span>

		<span class="n">OP_EXTRACT</span><span class="p">,</span>					<span class="cm">/**&lt; extract part of a date, extract identity from a PIN ID */</span>
		<span class="n">OP_BITFIELD</span><span class="p">,</span>				<span class="cm">/**&lt; extract a bit field from a number or a binary string */</span>
		<span class="n">OP_CALL</span><span class="p">,</span>					<span class="cm">/**&lt; call a function of code block with parameters */</span>
		<span class="n">OP_CASE</span><span class="p">,</span>					<span class="cm">/**&lt; CASE ... WHEN ... THEN ... END construct */</span>

		<span class="n">OP_ALL</span>
	<span class="p">};</span>

	<span class="kr">inline</span>	<span class="n">bool</span>	<span class="nf">isBool</span><span class="p">(</span><span class="n">ExprOp</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="kt">unsigned</span><span class="p">(</span><span class="n">op</span><span class="o">-</span><span class="n">OP_FIRST_BOOLEAN</span><span class="p">)</span><span class="o">&lt;=</span><span class="kt">unsigned</span><span class="p">(</span><span class="n">OP_LAST_BOOLEAN</span><span class="o">-</span><span class="n">OP_FIRST_BOOLEAN</span><span class="p">);}</span>

	<span class="cm">/**</span>
<span class="cm">	 * operation modifiers (bit flags) passed to IExprNode::expr(...)</span>
<span class="cm">	 */</span>
<span class="cp">	#define	UNSIGNED_OP				0x0001	</span><span class="c1">// unsigned op (for right shift)</span>
<span class="cp">	#define	CASE_INSENSITIVE_OP		0x0001	</span><span class="c1">// case insensitive comparison of strings</span>
<span class="cp">	#define	FILTER_LAST_OP			0x0001	</span><span class="c1">// filter only last segment in OP_PATH repeating segment</span>
<span class="cp">	#define	NOT_BOOLEAN_OP			0x0002	</span><span class="c1">// logical NOT of a boolean operation (e.g. NOT CONTAINS, DOESN&#39;T EXIST)</span>
<span class="cp">	#define	DISTINCT_OP				0x0002	</span><span class="c1">// DICTINCT modifier for aggregate functions</span>
<span class="cp">	#define	QUEST_PATH_OP			0x0002	</span><span class="c1">// OP_PATH: a.b{?}</span>
<span class="cp">	#define	EXCLUDE_LBOUND_OP		0x0004	</span><span class="c1">// exclude lower bound in &#39;in [a,b]&#39;</span>
<span class="cp">	#define	PLUS_PATH_OP			0x0004	</span><span class="c1">// OP_PATH: a.b{+}</span>
<span class="cp">	#define	STAR_PATH_OP			0x0006	</span><span class="c1">// OP_PATH: a.b{*}</span>
<span class="cp">	#define	EXCLUDE_RBOUND_OP		0x0008	</span><span class="c1">// exclude upper bound in &#39;in [a,b]&#39;</span>
<span class="cp">	#define	FOR_ALL_LEFT_OP			0x0010	</span><span class="c1">// quantification of the left argument of a comparison</span>
<span class="cp">	#define	EXISTS_LEFT_OP			0x0020	</span><span class="c1">// quantification of the left argument of a comparison</span>
<span class="cp">	#define	FOR_ALL_RIGHT_OP		0x0040	</span><span class="c1">// quantification of the right argument of a comparison</span>
<span class="cp">	#define	EXISTS_RIGHT_OP			0x0080	</span><span class="c1">// quantification of the right argument of a comparison</span>
<span class="cp">	#define	NULLS_NOT_INCLUDED_OP	0x0100	</span><span class="c1">// missing property doesn&#39;t satisfy OP_NE (or !OP_EQ) condition</span>

	<span class="k">struct</span>	<span class="n">Value</span><span class="p">;</span>
	<span class="n">class</span>	<span class="n">IPIN</span><span class="p">;</span>
	<span class="n">class</span>	<span class="n">IStoreInspector</span><span class="p">;</span>

	<span class="cm">/**</span>
<span class="cm">	 * PIN ID representation: 64-bit integer + 32-bit representing identity</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">PID</span>
	<span class="p">{</span>
		<span class="kt">uint64_t</span>	<span class="n">pid</span><span class="p">;</span>
		<span class="n">IdentityID</span>	<span class="n">ident</span><span class="p">;</span>
		<span class="n">operator</span>	<span class="kt">uint32_t</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">pid</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">)</span><span class="o">^</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span><span class="o">^</span><span class="n">ident</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">pid</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">pid</span> <span class="o">&amp;&amp;</span> <span class="n">ident</span><span class="o">==</span><span class="n">rhs</span><span class="p">.</span><span class="n">ident</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">pid</span><span class="o">!=</span><span class="n">rhs</span><span class="p">.</span><span class="n">pid</span> <span class="o">||</span> <span class="n">ident</span><span class="o">!=</span><span class="n">rhs</span><span class="p">.</span><span class="n">ident</span><span class="p">;}</span>
		<span class="kt">void</span>		<span class="n">setStoreID</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">sid</span><span class="p">)</span> <span class="p">{</span><span class="n">pid</span><span class="o">=</span><span class="p">(</span><span class="n">pid</span><span class="o">&amp;</span><span class="mh">0x0000FFFFFFFFFFFFULL</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">48</span><span class="p">);}</span>
		<span class="n">bool</span>		<span class="n">isPID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">pid</span><span class="o">!=</span><span class="n">STORE_INVALID_PID</span> <span class="o">&amp;&amp;</span> <span class="n">ident</span><span class="o">!=</span><span class="n">STORE_INVALID_IDENTITY</span> <span class="o">&amp;&amp;</span> <span class="n">ident</span><span class="o">!=</span><span class="n">STORE_INMEM_IDENTITY</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">isEmpty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">pid</span><span class="o">==</span><span class="n">STORE_INVALID_PID</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">isTPID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">pid</span><span class="o">!=</span><span class="n">STORE_INVALID_PID</span> <span class="o">&amp;&amp;</span> <span class="n">ident</span><span class="o">==</span><span class="n">STORE_INVALID_IDENTITY</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">isPtr</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">pid</span><span class="o">!=</span><span class="mi">0ULL</span> <span class="o">&amp;&amp;</span> <span class="n">ident</span><span class="o">==</span><span class="n">STORE_INMEM_IDENTITY</span><span class="p">;}</span>
		<span class="kt">void</span>		<span class="n">setEmpty</span><span class="p">()</span> <span class="p">{</span><span class="n">pid</span><span class="o">=</span><span class="n">STORE_INVALID_PID</span><span class="p">;</span> <span class="n">ident</span><span class="o">=</span><span class="n">STORE_INVALID_IDENTITY</span><span class="p">;}</span>
		<span class="kt">void</span>		<span class="n">setTPID</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">pid</span><span class="o">=</span><span class="n">t</span><span class="p">;</span> <span class="n">ident</span><span class="o">=</span><span class="n">STORE_INVALID_IDENTITY</span><span class="p">;}</span>
		<span class="kt">void</span>		<span class="n">setPtr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="n">pid</span><span class="o">=</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">p</span><span class="p">;</span> <span class="n">ident</span><span class="o">=</span><span class="n">STORE_INMEM_IDENTITY</span><span class="p">;}</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * PIN ID augmented by version ID (for future implementation of versioning)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">VPID</span>
	<span class="p">{</span>
		<span class="kt">uint64_t</span>	<span class="n">pid</span><span class="p">;</span>
		<span class="n">IdentityID</span>	<span class="n">ident</span><span class="p">;</span>
		<span class="n">VersionID</span>	<span class="n">vid</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * reference to a PIN data element (property or an element of a collection property) + version</span>
<span class="cm">	 * @see VT_REFPROP and VT_REFELT in Value</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">RefP</span>
	<span class="p">{</span>
		<span class="n">IPIN</span>		<span class="o">*</span><span class="n">pin</span><span class="p">;</span>
		<span class="n">PropertyID</span>	<span class="n">pid</span><span class="p">;</span>
		<span class="n">ElementID</span>	<span class="n">eid</span><span class="p">;</span>
		<span class="n">VersionID</span>	<span class="n">vid</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * reference to a PIN data element (PID, property or an element of a collection property) + version</span>
<span class="cm">	 * @see VT_REDIDPROP and VT_REFIDELT in Value</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">RefVID</span>
	<span class="p">{</span>
		<span class="n">PID</span>			<span class="n">id</span><span class="p">;</span>
		<span class="n">PropertyID</span>	<span class="n">pid</span><span class="p">;</span>
		<span class="n">ElementID</span>	<span class="n">eid</span><span class="p">;</span>
		<span class="n">VersionID</span>	<span class="n">vid</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * generic stream interface for input and output parameters</span>
<span class="cm">	 * @see VT_STREAM in Value</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">IStream</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span> <span class="n">ValueType</span>	<span class="n">dataType</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">uint64_t</span>	<span class="n">length</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">size_t</span>		<span class="n">read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">maxLength</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">readChunk</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">IStream</span>		<span class="o">*</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">reset</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">void</span>		<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span>	<span class="n">IStreamRef</span> <span class="p">{</span>
		<span class="n">IStream</span>			<span class="o">*</span><span class="n">is</span><span class="p">;</span>
		<span class="n">mutable</span>	<span class="kt">void</span>	<span class="o">*</span><span class="n">prefix</span><span class="p">;</span>
	<span class="p">};</span>

<span class="cp">	#define	VAR_TYPE_MASK	0xE000		</span><span class="c1">// mask for RefV::flags field</span>
<span class="cp">	#define	VAR_PARAM		0x2000		</span><span class="c1">// external parameter reference; other bits reserved for internal use</span>

	<span class="cm">/**</span>
<span class="cm">	 * VT_VARREF representation</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">RefV</span>
	<span class="p">{</span>
		<span class="n">PropertyID</span>			<span class="n">id</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="kt">short</span>	<span class="n">flags</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="kt">short</span>	<span class="n">type</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="kt">char</span>	<span class="n">refN</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="kt">char</span>	<span class="n">filler</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * collection navigation operations</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">GO_DIR</span>
	<span class="p">{</span>
		<span class="n">GO_FIRST</span><span class="p">,</span><span class="n">GO_LAST</span><span class="p">,</span><span class="n">GO_NEXT</span><span class="p">,</span><span class="n">GO_PREVIOUS</span><span class="p">,</span><span class="n">GO_FINDBYID</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * collection interface for in and out parameters</span>
<span class="cm">	 * @see VT_COLLECTION in Value</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">INav</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="k">const</span>	<span class="n">Value</span>			<span class="o">*</span><span class="n">navigate</span><span class="p">(</span><span class="n">GO_DIR</span><span class="o">=</span><span class="n">GO_NEXT</span><span class="p">,</span><span class="n">ElementID</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="n">ElementID</span>		<span class="n">getCurrentID</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="k">const</span>	<span class="n">Value</span>			<span class="o">*</span><span class="n">getCurrentValue</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="n">RC</span>				<span class="n">getElementByID</span><span class="p">(</span><span class="n">ElementID</span><span class="p">,</span><span class="n">Value</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="n">INav</span>			<span class="o">*</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="kt">unsigned</span>		<span class="n">count</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="kt">void</span>			<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * map interface for in and out parameters</span>
<span class="cm">	 * @see VT_MAP in Value</span>
<span class="cm">	 */</span>

<span class="cp">	#define	IMAP_FIRST		0x0001		</span><span class="cm">/**&lt; return first (last if IMAP_REVERSE is set) element of the map */</span><span class="cp"></span>
<span class="cp">	#define	IMAP_REVERSE	0x0002		</span><span class="cm">/**&lt; return elements in reverse order */</span><span class="cp"></span>

	<span class="n">class</span> <span class="n">IMap</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="k">const</span>	<span class="n">Value</span>			<span class="o">*</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="n">RC</span>				<span class="n">getNext</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*&amp;</span><span class="n">key</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*&amp;</span><span class="n">val</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="n">IMap</span>			<span class="o">*</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="kt">unsigned</span>		<span class="n">count</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>			<span class="kt">void</span>			<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="k">struct</span> <span class="n">IndexSeg</span>
	<span class="p">{</span>
		<span class="kt">uint32_t</span>	<span class="n">propID</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">flags</span><span class="p">;</span>
		<span class="kt">uint16_t</span>	<span class="n">lPrefix</span><span class="p">;</span>
		<span class="kt">uint8_t</span>		<span class="n">type</span><span class="p">;</span>
		<span class="kt">uint8_t</span>		<span class="n">op</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * OP_EDIT data</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">StrEdit</span>
	<span class="p">{</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="k">const</span>	<span class="kt">char</span>		<span class="o">*</span><span class="n">str</span><span class="p">;</span>
			<span class="k">const</span>	<span class="kt">uint8_t</span>		<span class="o">*</span><span class="n">bstr</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint32_t</span>				<span class="n">length</span><span class="p">;</span>				<span class="cm">/**&lt; shift+length must be &lt;= the length of the string being edited */</span>
		<span class="kt">uint64_t</span>				<span class="n">shift</span><span class="p">;</span>				<span class="cm">/**&lt; shift==~0ULL means &#39;end of string&#39;; in this case length must be 0 */</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">BitEdit</span>
	<span class="p">{</span>
		<span class="kt">uint32_t</span>	<span class="n">bits</span><span class="p">;</span>
		<span class="kt">uint32_t</span>	<span class="n">mask</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">BitEdit64</span>
	<span class="p">{</span>
		<span class="kt">uint64_t</span>	<span class="n">bits</span><span class="p">;</span>
		<span class="kt">uint64_t</span>	<span class="n">mask</span><span class="p">;</span>
	<span class="p">};</span>
		
	<span class="cm">/**</span>
<span class="cm">	 * floating value with measurement unit information</span>
<span class="cm">	 * @see VT_DOUBLE and VT_FLOAT in Value</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">QualifiedValue</span>
	<span class="p">{</span>
		<span class="kt">double</span>			<span class="n">d</span><span class="p">;</span>
		<span class="kt">uint16_t</span>		<span class="n">units</span><span class="p">;</span>						<span class="cm">/**&lt; value form Units enumeration, see units.h */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * representation of an element of enumeration</span>
<span class="cm">	 * @see VT_ENUM in Value</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">VEnum</span>
	<span class="p">{</span>
		<span class="n">URIID</span>			<span class="n">enumid</span><span class="p">;</span>
		<span class="n">ElementID</span>		<span class="n">eltid</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * representation of a fixed size array</span>
<span class="cm">	 * @see VT_ARRAY in Value</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">FixedArray</span>
	<span class="p">{</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="kt">int32_t</span>		<span class="o">*</span><span class="n">i</span><span class="p">;</span>
			<span class="kt">uint32_t</span>	<span class="o">*</span><span class="n">ui</span><span class="p">;</span>
			<span class="kt">int64_t</span>		<span class="o">*</span><span class="n">i64</span><span class="p">;</span>
			<span class="kt">uint64_t</span>	<span class="o">*</span><span class="n">ui64</span><span class="p">;</span>
			<span class="n">TIMESTAMP</span>	<span class="o">*</span><span class="n">ts</span><span class="p">;</span>
			<span class="kt">float</span>		<span class="o">*</span><span class="n">f</span><span class="p">;</span>
			<span class="kt">double</span>		<span class="o">*</span><span class="n">d</span><span class="p">;</span>
			<span class="n">PID</span>			<span class="o">*</span><span class="n">id</span><span class="p">;</span>
			<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint16_t</span>		<span class="n">xdim</span><span class="p">;</span>			<span class="c1">// vector size or matrix X-dimension</span>
		<span class="kt">uint16_t</span>		<span class="n">ydim</span><span class="p">;</span>			<span class="c1">// matrix Y-dimension, 0 for vectors</span>
		<span class="kt">uint16_t</span>		<span class="n">start</span><span class="p">;</span>			<span class="c1">// index of the first element for circular 1-dimensional arrays, set by the kernel</span>
		<span class="kt">uint16_t</span>		<span class="n">units</span><span class="p">;</span>			<span class="c1">// (optional) units for VT_DOUBLE,VT_FLOAT</span>
		<span class="kt">uint8_t</span>			<span class="n">type</span><span class="p">;</span>			<span class="c1">// data type of element arrays (VT_INT-VT_DOUBLE,VT_DATETIME,VT_REFID,VT_STRUCT)</span>
		<span class="n">mutable</span> <span class="kt">uint8_t</span>	<span class="n">flags</span><span class="p">;</span>			<span class="c1">// internal use</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">FixedStruct</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">StructDscr</span>
		<span class="p">{</span>
			<span class="n">PropertyID</span>		<span class="n">property</span><span class="p">;</span>
			<span class="kt">uint16_t</span>		<span class="n">length</span><span class="p">;</span>
			<span class="kt">uint8_t</span>			<span class="n">type</span><span class="p">;</span>
			<span class="kt">uint8_t</span>			<span class="n">flags</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="kt">uint32_t</span>		<span class="n">nDscr</span><span class="p">;</span>
		<span class="n">StructDscr</span>		<span class="n">dscr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="c1">// nDscr StructDscr field descriptors followed by data elements</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * main unit of information exchange interface; can contain data of various types, property ID, element ID, metaproperties, operation, etc.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">Value</span>
	<span class="p">{</span>
					<span class="n">PropertyID</span>	<span class="n">property</span><span class="p">;</span>
		<span class="n">mutable</span>		<span class="n">ElementID</span>	<span class="n">eid</span><span class="p">;</span>
					<span class="kt">uint32_t</span>	<span class="n">length</span><span class="p">;</span>
					<span class="kt">uint8_t</span>		<span class="n">type</span><span class="p">;</span>
					<span class="kt">uint8_t</span>		<span class="n">op</span><span class="p">;</span>
					<span class="kt">uint8_t</span>		<span class="n">meta</span><span class="p">;</span>
					<span class="kt">uint8_t</span>		<span class="n">fcalc</span>	<span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">mutable</span>		<span class="kt">uint8_t</span>		<span class="n">flags</span>	<span class="o">:</span><span class="mi">7</span><span class="p">;</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="k">const</span>	<span class="kt">char</span>		<span class="o">*</span><span class="n">str</span><span class="p">;</span>
			<span class="k">const</span>	<span class="kt">uint8_t</span>		<span class="o">*</span><span class="n">bstr</span><span class="p">;</span>
					<span class="kt">int32_t</span>		<span class="n">i</span><span class="p">;</span>
					<span class="kt">uint32_t</span>	<span class="n">ui</span><span class="p">;</span>
					<span class="kt">int64_t</span>		<span class="n">i64</span><span class="p">;</span>
					<span class="kt">uint64_t</span>	<span class="n">ui64</span><span class="p">;</span>
					<span class="n">TIMESTAMP</span>	<span class="n">ts</span><span class="p">;</span>
					<span class="n">VEnum</span>		<span class="n">enu</span><span class="p">;</span>
					<span class="kt">float</span>		<span class="n">f</span><span class="p">;</span>
					<span class="kt">double</span>		<span class="n">d</span><span class="p">;</span>
					<span class="n">PID</span>			<span class="n">id</span><span class="p">;</span>
					<span class="n">VPID</span>		<span class="n">vpid</span><span class="p">;</span>
					<span class="n">IPIN</span>		<span class="o">*</span><span class="n">pin</span><span class="p">;</span>
			<span class="k">const</span>	<span class="n">RefVID</span>		<span class="o">*</span><span class="n">refId</span><span class="p">;</span>
					<span class="n">RefP</span>		<span class="n">ref</span><span class="p">;</span>
			<span class="k">const</span>	<span class="n">Value</span>		<span class="o">*</span><span class="n">varray</span><span class="p">;</span>
					<span class="n">INav</span>		<span class="o">*</span><span class="n">nav</span><span class="p">;</span>
					<span class="n">IMap</span>		<span class="o">*</span><span class="n">map</span><span class="p">;</span>
					<span class="n">Value</span>		<span class="o">*</span><span class="n">range</span><span class="p">;</span>
					<span class="n">bool</span>		<span class="n">b</span><span class="p">;</span>
					<span class="n">URIID</span>		<span class="n">uid</span><span class="p">;</span>
					<span class="n">IdentityID</span>	<span class="n">iid</span><span class="p">;</span>
					<span class="n">IStreamRef</span>	<span class="n">stream</span><span class="p">;</span>
			<span class="n">class</span>	<span class="n">IStmt</span>		<span class="o">*</span><span class="n">stmt</span><span class="p">;</span>
			<span class="n">class</span>	<span class="n">IExpr</span>		<span class="o">*</span><span class="n">expr</span><span class="p">;</span>
			<span class="n">class</span>	<span class="n">IExprNode</span>	<span class="o">*</span><span class="n">exprt</span><span class="p">;</span>
					<span class="n">RefV</span>		<span class="n">refV</span><span class="p">;</span>
					<span class="n">StrEdit</span>		<span class="n">edit</span><span class="p">;</span>
					<span class="n">BitEdit</span>		<span class="n">bedt</span><span class="p">;</span>
					<span class="n">BitEdit64</span>	<span class="n">bedt64</span><span class="p">;</span>
					<span class="n">IndexSeg</span>	<span class="n">iseg</span><span class="p">;</span>
			<span class="n">QualifiedValue</span>		<span class="n">qval</span><span class="p">;</span>
			<span class="n">FixedArray</span>			<span class="n">fa</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="nl">public:</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STRING</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="o">==</span><span class="nb">NULL</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">str</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">nChars</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STRING</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">nChars</span><span class="p">;</span> <span class="n">str</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_BSTR</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">l</span><span class="p">;</span> <span class="n">bstr</span><span class="o">=</span><span class="n">bs</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_INT</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int32_t</span><span class="p">);</span> <span class="n">i</span><span class="o">=</span><span class="n">ii</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_UINT</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="n">ui</span><span class="o">=</span><span class="n">u</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setI64</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">ii</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_INT64</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">);</span> <span class="n">i64</span><span class="o">=</span><span class="n">ii</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setU64</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_UINT64</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span> <span class="n">ui64</span><span class="o">=</span><span class="n">u</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEnum</span><span class="p">(</span><span class="n">URIID</span> <span class="n">en</span><span class="p">,</span><span class="n">ElementID</span> <span class="n">ei</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_ENUM</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VEnum</span><span class="p">);</span> <span class="n">enu</span><span class="p">.</span><span class="n">enumid</span><span class="o">=</span><span class="n">en</span><span class="p">;</span> <span class="n">enu</span><span class="p">.</span><span class="n">eltid</span><span class="o">=</span><span class="n">ei</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="kt">float</span> <span class="n">fl</span><span class="p">,</span><span class="n">Units</span> <span class="n">pu</span><span class="o">=</span><span class="n">Un_NDIM</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_FLOAT</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span> <span class="n">f</span><span class="o">=</span><span class="n">fl</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">qval</span><span class="p">.</span><span class="n">units</span><span class="o">=</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">pu</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="kt">double</span> <span class="n">dd</span><span class="p">,</span><span class="n">Units</span> <span class="n">pu</span><span class="o">=</span><span class="n">Un_NDIM</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_DOUBLE</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="n">d</span><span class="o">=</span><span class="n">dd</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">qval</span><span class="p">.</span><span class="n">units</span><span class="o">=</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">pu</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">IPIN</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_REF</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">IPIN</span><span class="o">*</span><span class="p">);</span> <span class="n">pin</span><span class="o">=</span><span class="n">ip</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">pi</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_REFID</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PID</span><span class="p">);</span> <span class="n">id</span><span class="o">=</span><span class="n">pi</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">RefVID</span><span class="o">&amp;</span> <span class="n">re</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">eid</span><span class="o">==</span><span class="n">STORE_COLLECTION_ID</span><span class="o">?</span><span class="n">VT_REFIDPROP</span><span class="o">:</span><span class="n">VT_REFIDELT</span><span class="p">);</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">refId</span><span class="o">=&amp;</span><span class="n">re</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">RefP</span><span class="o">&amp;</span> <span class="n">re</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">eid</span><span class="o">==</span><span class="n">STORE_COLLECTION_ID</span><span class="o">?</span><span class="n">VT_REFPROP</span><span class="o">:</span><span class="n">VT_REFELT</span><span class="p">);</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">ref</span><span class="o">=</span><span class="n">re</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setArray</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">nValues</span><span class="p">,</span><span class="kt">uint16_t</span> <span class="n">xdim</span><span class="p">,</span><span class="kt">uint16_t</span> <span class="n">ydim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ValueType</span> <span class="n">vt</span><span class="o">=</span><span class="n">VT_DOUBLE</span><span class="p">,</span><span class="n">Units</span> <span class="n">pu</span><span class="o">=</span><span class="n">Un_NDIM</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_ARRAY</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">nValues</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">data</span><span class="o">=</span><span class="n">arr</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">xdim</span><span class="o">=</span><span class="n">xdim</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">ydim</span><span class="o">=</span><span class="n">ydim</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">units</span><span class="o">=</span><span class="n">pu</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">type</span><span class="o">=</span><span class="n">vt</span><span class="p">;</span> <span class="n">fa</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">coll</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">nValues</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_COLLECTION</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">f</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">nValues</span><span class="p">;</span> <span class="n">varray</span><span class="o">=</span><span class="n">coll</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">INav</span> <span class="o">*</span><span class="n">nv</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_COLLECTION</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">f</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=~</span><span class="mi">0u</span><span class="p">;</span> <span class="n">nav</span><span class="o">=</span><span class="n">nv</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setStruct</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">coll</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">nValues</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STRUCT</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">f</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">nValues</span><span class="p">;</span> <span class="n">varray</span><span class="o">=</span><span class="n">coll</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">IMap</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_MAP</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">map</span><span class="o">=</span><span class="n">mp</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">bool</span> <span class="n">bl</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_BOOL</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">bool</span><span class="p">);</span> <span class="n">b</span><span class="o">=</span><span class="n">bl</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setDateTime</span><span class="p">(</span><span class="n">TIMESTAMP</span> <span class="n">datetime</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_DATETIME</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">);</span> <span class="n">ts</span><span class="o">=</span><span class="n">datetime</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setInterval</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">intvl</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_INTERVAL</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">);</span> <span class="n">i64</span><span class="o">=</span><span class="n">intvl</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">IStream</span> <span class="o">*</span><span class="n">strm</span><span class="p">,</span><span class="n">bool</span> <span class="n">fPB</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STREAM</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">fPB</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">stream</span><span class="p">.</span><span class="n">is</span><span class="o">=</span><span class="n">strm</span><span class="p">;</span> <span class="n">stream</span><span class="p">.</span><span class="n">prefix</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">IStmt</span> <span class="o">*</span><span class="n">stm</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STMT</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">f</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">stmt</span><span class="o">=</span><span class="n">stm</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_EXPRTREE</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">exprt</span><span class="o">=</span><span class="n">ex</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">set</span><span class="p">(</span><span class="n">IExpr</span> <span class="o">*</span><span class="n">ex</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_EXPR</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">f</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">expr</span><span class="o">=</span><span class="n">ex</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setParam</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pn</span><span class="p">,</span><span class="n">ValueType</span> <span class="n">ty</span><span class="o">=</span><span class="n">VT_ANY</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_VARREF</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">refN</span><span class="o">=</span><span class="n">pn</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">type</span><span class="o">=</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">ty</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="p">(</span><span class="n">f</span><span class="o">&amp;~</span><span class="n">VAR_TYPE_MASK</span><span class="p">)</span><span class="o">|</span><span class="n">VAR_PARAM</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setVarRef</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">vn</span><span class="p">,</span><span class="n">PropertyID</span> <span class="n">id</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">,</span><span class="n">ValueType</span> <span class="n">ty</span><span class="o">=</span><span class="n">VT_ANY</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_VARREF</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">id</span><span class="o">!=</span><span class="n">STORE_INVALID_URIID</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">refN</span><span class="o">=</span><span class="n">vn</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">type</span><span class="o">=</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">ty</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">flags</span><span class="o">=</span><span class="n">f</span><span class="o">&amp;~</span><span class="n">VAR_TYPE_MASK</span><span class="p">;</span> <span class="n">refV</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">id</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setRange</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">rng</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_RANGE</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="n">f</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">range</span><span class="o">=</span><span class="n">rng</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setURIID</span><span class="p">(</span><span class="n">URIID</span> <span class="n">uri</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_URIID</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="n">uid</span><span class="o">=</span><span class="n">uri</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setIdentity</span><span class="p">(</span><span class="n">IdentityID</span> <span class="n">ii</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_IDENTITY</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="n">iid</span><span class="o">=</span><span class="n">ii</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setNow</span><span class="p">()</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_CURRENT</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">CVT_TIMESTAMP</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setCUser</span><span class="p">()</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_CURRENT</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">CVT_USER</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setCStore</span><span class="p">()</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_CURRENT</span><span class="p">;</span> <span class="n">i</span><span class="o">=</span><span class="n">CVT_STORE</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEdit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="n">sht</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STRING</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_EDIT</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">s</span><span class="o">==</span><span class="nb">NULL</span><span class="o">?</span><span class="mi">0</span><span class="o">:</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">edit</span><span class="p">.</span><span class="n">str</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">shift</span><span class="o">=</span><span class="n">sht</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">l</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEdit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">nChars</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="n">sht</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_STRING</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_EDIT</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">nChars</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">str</span><span class="o">=</span><span class="n">s</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">shift</span><span class="o">=</span><span class="n">sht</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">l</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEdit</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">l</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="n">sht</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">ll</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_BSTR</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_EDIT</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="n">l</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">bstr</span><span class="o">=</span><span class="n">bs</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">shift</span><span class="o">=</span><span class="n">sht</span><span class="p">;</span> <span class="n">edit</span><span class="p">.</span><span class="n">length</span><span class="o">=</span><span class="n">ll</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEdit</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">bt</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">msk</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_UINT</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_EDIT</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BitEdit</span><span class="p">);</span> <span class="n">bedt</span><span class="p">.</span><span class="n">bits</span><span class="o">=</span><span class="n">bt</span><span class="p">;</span> <span class="n">bedt</span><span class="p">.</span><span class="n">mask</span><span class="o">=</span><span class="n">msk</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEdit</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">bt</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="n">msk</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_UINT64</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_EDIT</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BitEdit64</span><span class="p">);</span> <span class="n">bedt64</span><span class="p">.</span><span class="n">bits</span><span class="o">=</span><span class="n">bt</span><span class="p">;</span> <span class="n">bedt64</span><span class="p">.</span><span class="n">mask</span><span class="o">=</span><span class="n">msk</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setRename</span><span class="p">(</span><span class="n">PropertyID</span> <span class="n">from</span><span class="p">,</span><span class="n">PropertyID</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_URIID</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">from</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_RENAME</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PropertyID</span><span class="p">);</span> <span class="n">uid</span><span class="o">=</span><span class="n">to</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setDelete</span><span class="p">(</span><span class="n">PropertyID</span> <span class="n">p</span><span class="p">,</span><span class="n">ElementID</span> <span class="n">ei</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_ANY</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">p</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_DELETE</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">ei</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setError</span><span class="p">(</span><span class="n">PropertyID</span> <span class="n">pid</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">)</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_ERROR</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">pid</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
		<span class="kt">void</span>	<span class="nf">setEmpty</span><span class="p">()</span> <span class="p">{</span><span class="n">type</span><span class="o">=</span><span class="n">VT_ERROR</span><span class="p">;</span> <span class="n">property</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">;</span> <span class="n">fcalc</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">op</span><span class="o">=</span><span class="n">OP_SET</span><span class="p">;</span> <span class="n">eid</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">;</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">meta</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>

		<span class="kt">void</span>		<span class="nf">setOp</span><span class="p">(</span><span class="n">ExprOp</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span><span class="n">op</span><span class="o">=</span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">o</span><span class="p">);}</span>
		<span class="kt">void</span>		<span class="nf">setMeta</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">mt</span><span class="p">)</span> <span class="p">{</span><span class="n">meta</span><span class="o">=</span><span class="n">mt</span><span class="p">;}</span>
		<span class="kt">void</span>		<span class="nf">setPropID</span><span class="p">(</span><span class="n">PropertyID</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="n">property</span><span class="o">=</span><span class="n">p</span><span class="p">;}</span>
		<span class="n">PropertyID</span>	<span class="n">getPropID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">property</span><span class="p">;}</span>
		<span class="n">operator</span>	<span class="n">PropertyID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">property</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">isFTIndexable</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">type</span><span class="o">==</span><span class="n">VT_STRING</span> <span class="o">||</span> <span class="p">(</span><span class="n">type</span><span class="o">==</span><span class="n">VT_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">stream</span><span class="p">.</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">dataType</span><span class="p">()</span><span class="o">==</span><span class="n">VT_STRING</span><span class="p">);}</span>
		<span class="n">bool</span>		<span class="n">isEmpty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">type</span><span class="o">==</span><span class="n">VT_ERROR</span><span class="p">;}</span>
		<span class="n">bool</span>		<span class="n">isNav</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="n">assert</span><span class="p">(</span><span class="n">type</span><span class="o">==</span><span class="n">VT_COLLECTION</span><span class="p">);</span> <span class="k">return</span> <span class="n">length</span><span class="o">==~</span><span class="mi">0u</span><span class="p">;}</span>
		<span class="kt">unsigned</span>	<span class="n">count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">type</span><span class="o">==</span><span class="n">VT_ANY</span><span class="o">?</span><span class="mi">0u</span><span class="o">:</span><span class="n">type</span><span class="o">!=</span><span class="n">VT_COLLECTION</span><span class="o">?</span><span class="mi">1u</span><span class="o">:</span><span class="n">length</span><span class="o">!=~</span><span class="mi">0u</span><span class="o">?</span><span class="n">length</span><span class="o">:</span><span class="n">nav</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">();}</span>
		<span class="k">static</span>	<span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">find</span><span class="p">(</span><span class="n">PropertyID</span> <span class="n">pid</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nv</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vals</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">while</span> <span class="p">(</span><span class="n">nv</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="n">k</span><span class="o">=</span><span class="n">nv</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">q</span><span class="o">=&amp;</span><span class="n">vals</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> 
				<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">property</span><span class="o">&lt;</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span><span class="n">nv</span><span class="o">-=++</span><span class="n">k</span><span class="p">;</span> <span class="n">vals</span><span class="o">+=</span><span class="n">k</span><span class="p">;}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">property</span><span class="o">&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="n">nv</span><span class="o">=</span><span class="n">k</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="n">q</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * The main interface to manipulate PINs.</span>
<span class="cm">	 * Allows to enumerate all properties of a PIN, as well as to</span>
<span class="cm">	 * create, query, modify and delete properties.</span>
<span class="cm">	 * @see ISession</span>
<span class="cm">	 */</span>
	
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IPIN</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span>	<span class="n">getPID</span><span class="p">()</span> <span class="k">const</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; returns PIN ID */</span>
		<span class="k">virtual</span>	<span class="n">bool</span>		<span class="n">isLocal</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; check the PIN is local, i.e. neither replicated, nor remoted cached */</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getFlags</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; retireve PIN flags (PIN_*) */</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getMetaType</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; retrieve PIN metatype as a set of flags (@see PMT_* flags) */</span>
		<span class="k">virtual</span>	<span class="kt">uint32_t</span>	<span class="n">getNumberOfProperties</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; number of PIN properties */</span>
		<span class="k">virtual</span>	<span class="k">const</span> <span class="n">Value</span>	<span class="o">*</span><span class="n">getValueByIndex</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; get property value by index [0..getNumberOfProperties()-1] */</span>
		<span class="k">virtual</span>	<span class="k">const</span> <span class="n">Value</span>	<span class="o">*</span><span class="n">getValue</span><span class="p">(</span><span class="n">PropertyID</span> <span class="n">pid</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; get property value by property ID */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getPINValue</span><span class="p">(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; get PIN &#39;value&#39;, based on PROP_SPEC_VALUE */</span>

		<span class="k">virtual</span>	<span class="n">bool</span>		<span class="n">testClassMembership</span><span class="p">(</span><span class="n">ClassID</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; test if the PIN is a member of class */</span>
		<span class="k">virtual</span>	<span class="n">bool</span>		<span class="n">defined</span><span class="p">(</span><span class="k">const</span> <span class="n">PropertyID</span> <span class="o">*</span><span class="n">pids</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProps</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; test if properties exists in the PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">isMemberOf</span><span class="p">(</span><span class="n">ClassID</span> <span class="o">*&amp;</span><span class="n">clss</span><span class="p">,</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">nclss</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; returns an array of ClassIDs the PIN is a member of */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">refresh</span><span class="p">(</span><span class="n">bool</span> <span class="n">fNet</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																							<span class="cm">/**&lt; refresh PIN, i.e. re-read properties from persistent storage */</span>
		<span class="k">virtual</span>	<span class="n">IPIN</span>		<span class="o">*</span><span class="n">clone</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">overwriteValues</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nOverwriteValues</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; clone PIN (optionally modifying some properties) */</span>
		<span class="k">virtual</span>	<span class="n">IPIN</span>		<span class="o">*</span><span class="n">project</span><span class="p">(</span><span class="k">const</span> <span class="n">PropertyID</span> <span class="o">*</span><span class="n">properties</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProperties</span><span class="p">,</span><span class="k">const</span> <span class="n">PropertyID</span> <span class="o">*</span><span class="n">newProps</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; project PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">modify</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">ElementID</span> <span class="o">*</span><span class="n">eids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">pNFailed</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; modify PIN, can be applied to uncommitted PINs */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">setExpiration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>				<span class="cm">/**&lt; set expiration time for cached remote PINs */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">setNotification</span><span class="p">(</span><span class="n">bool</span> <span class="n">fReset</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; switch notification generation on or off for this PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">setReplicated</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; set &#39;replicatable&#39; status */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">hide</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; exclude from indexes and hide */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">deletePIN</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; soft-delete PIN from persistent stoarge */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">undelete</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; undelete soft-deleted PIN */</span>

		<span class="k">virtual</span>	<span class="n">IMemAlloc</span>	<span class="o">*</span><span class="n">getAlloc</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; get memory allocator of this PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">allocSubPIN</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nProps</span><span class="p">,</span><span class="n">IPIN</span> <span class="o">*&amp;</span><span class="n">pin</span><span class="p">,</span><span class="n">Value</span> <span class="o">*&amp;</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; allocate space for a sub-PIN in the same heap */</span>

		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; destroy this IPIN (doesn&#39;t delete it from DB) */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * QName declaration structure; fDel for internal use only</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">AFY_EXP</span> <span class="n">QName</span>
	<span class="p">{</span>
		<span class="k">const</span>	<span class="kt">char</span>	<span class="o">*</span><span class="n">qpref</span><span class="p">;</span>
		<span class="kt">size_t</span>			<span class="n">lq</span><span class="p">;</span>
		<span class="k">const</span>	<span class="kt">char</span>	<span class="o">*</span><span class="n">str</span><span class="p">;</span>
		<span class="kt">size_t</span>			<span class="n">lstr</span><span class="p">;</span>
		<span class="n">bool</span>			<span class="n">fDel</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * compilation error information: type of error, position, etc.</span>
<span class="cm">	 * @see createXXX() functions</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">AFY_EXP</span> <span class="n">CompilationError</span>
	<span class="p">{</span>
		<span class="n">RC</span>				<span class="n">rc</span><span class="p">;</span>
		<span class="k">const</span>	<span class="kt">char</span>	<span class="o">*</span><span class="n">msg</span><span class="p">;</span>
		<span class="kt">unsigned</span>		<span class="n">line</span><span class="p">;</span>
		<span class="kt">unsigned</span>		<span class="n">pos</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="n">AFY_EXP</span> <span class="kt">size_t</span>	<span class="n">errorToString</span><span class="p">(</span><span class="n">RC</span> <span class="n">rc</span><span class="p">,</span><span class="k">const</span> <span class="n">CompilationError</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[],</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">);</span>		<span class="cm">/**&lt; convert error information to string */</span>

	<span class="cm">/**</span>
<span class="cm">	 * Expression tree node interface</span>
<span class="cm">	 * @see ISession::expr()</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IExprNode</span> 
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span> <span class="n">ExprOp</span>			<span class="n">getOp</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>		<span class="n">getNumberOfOperands</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="k">const</span>	<span class="n">Value</span><span class="o">&amp;</span>	<span class="n">getOperand</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>		<span class="n">getFlags</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">setFlags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mask</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">IExpr</span>			<span class="o">*</span><span class="n">compile</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">char</span>			<span class="o">*</span><span class="n">toString</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">QName</span> <span class="o">*</span><span class="n">qNames</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nQNames</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="n">IExprNode</span>		<span class="o">*</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * Compiled expression interface</span>
<span class="cm">	 * @see IExprNode::compile()</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IExpr</span> 
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">execute</span><span class="p">(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">char</span>		<span class="o">*</span><span class="n">toString</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">QName</span> <span class="o">*</span><span class="n">qNames</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nQNames</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="n">IExpr</span>		<span class="o">*</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Query results iterator interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">ICursor</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">next</span><span class="p">(</span><span class="n">Value</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">next</span><span class="p">(</span><span class="n">PID</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">IPIN</span>		<span class="o">*</span><span class="n">next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="c1">// obsolete</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">rewind</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">uint64_t</span>	<span class="n">getCount</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Output protobuf stream interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IStreamOut</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">next</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">lBuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * Input protobuf stream interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IStreamIn</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">next</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">lBuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Free-text search flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define	QFT_FILTER_SW		0x0001</span>
<span class="cp">	#define	QFT_RET_NO_DOC		0x0002</span>
<span class="cp">	#define	QFT_RET_PARTS		0x0004</span>
<span class="cp">	#define	QFT_RET_NO_PARTS	0x0008</span>

	<span class="cm">/**</span>
<span class="cm">	 * Query variable types</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">QUERY_SETOP</span>
	<span class="p">{</span>
		<span class="n">QRY_SEMIJOIN</span><span class="p">,</span> <span class="n">QRY_JOIN</span><span class="p">,</span> <span class="n">QRY_LEFT_OUTER_JOIN</span><span class="p">,</span> <span class="n">QRY_RIGHT_OUTER_JOIN</span><span class="p">,</span> <span class="n">QRY_FULL_OUTER_JOIN</span><span class="p">,</span> <span class="n">QRY_UNION</span><span class="p">,</span> <span class="n">QRY_EXCEPT</span><span class="p">,</span> <span class="n">QRY_INTERSECT</span><span class="p">,</span> <span class="n">QRY_ALL_SETOP</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * INTO classes descriptor for INSERT</span>
<span class="cm">	 */</span>
<span class="cp">	#define	IC_UNIQUE		0x0001			</span><span class="cm">/**&lt; uniqueness constraint */</span><span class="cp"></span>
<span class="cp">	#define	IC_IDEMPOTENT	0x0002			</span><span class="cm">/**&lt; idempotent insert */</span><span class="cp"></span>
	
	<span class="k">struct</span>	<span class="n">IntoClass</span>
	<span class="p">{</span>
		<span class="n">ClassID</span>		<span class="n">cid</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Class specification for query variables</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">AFY_EXP</span> <span class="n">SourceSpec</span>
	<span class="p">{</span>
		<span class="n">URIID</span>			<span class="n">objectID</span><span class="p">;</span>			<span class="cm">/**&lt; named object PIN ID (class, template, comm, etc.) */</span>
		<span class="kt">unsigned</span>		<span class="n">nParams</span><span class="p">;</span>			<span class="cm">/**&lt; number of parameters for family reference */</span>
		<span class="k">const</span>	<span class="n">Value</span>	<span class="o">*</span><span class="n">params</span><span class="p">;</span>			<span class="cm">/**&lt; parameter values for family reference */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Path segment specification for query expressions and variables</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">AFY_EXP</span> <span class="n">PathSeg</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span>		<span class="n">nPids</span><span class="p">;</span>				<span class="cm">/**&lt; number of properties in pids array */</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="n">PropertyID</span>		<span class="n">pid</span><span class="p">;</span>			<span class="cm">/**&lt; property ID */</span>
			<span class="n">PropertyID</span>		<span class="o">*</span><span class="n">pids</span><span class="p">;</span>			<span class="cm">/**&lt; property IDs (if more than 1) */</span>
		<span class="p">};</span>
		<span class="n">Value</span>			<span class="n">eid</span><span class="p">;</span>				<span class="cm">/**&lt; collection/structure/map element index, if isEmpty() and eid is equal to STORE_COLLECTION_ID the whole collection/structure/map is used */</span>
		<span class="n">IExpr</span>			<span class="o">*</span><span class="n">filter</span><span class="p">;</span>			<span class="cm">/**&lt; filter expression; applied to PINs refered by this segment collection or single reference */</span>
		<span class="n">ClassID</span>			<span class="n">cid</span><span class="p">;</span>				<span class="cm">/**&lt; class the above PINs must be members of */</span>
		<span class="n">Value</span>			<span class="o">*</span><span class="n">params</span><span class="p">;</span>			<span class="cm">/**&lt; family parameter values */</span>
		<span class="kt">uint16_t</span>		<span class="n">nParams</span><span class="p">;</span>			<span class="cm">/**&lt; number of family parameters */</span>
		<span class="kt">uint16_t</span>		<span class="n">rmin</span><span class="p">;</span>				<span class="cm">/**&lt; minimum number of repetitions of this segment in valid path */</span>
		<span class="kt">uint16_t</span>		<span class="n">rmax</span><span class="p">;</span>				<span class="cm">/**&lt; maximum number of repetitions of this segment in valid path (0xFFFF - unlimited) */</span>
		<span class="n">bool</span>			<span class="n">fLast</span><span class="p">;</span>				<span class="cm">/**&lt; if repeating, filtering must be applied only to the last segment */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Ordering modifier flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define	ORD_DESC			0x01		</span><span class="cm">/**&lt; descending order */</span><span class="cp"></span>
<span class="cp">	#define	ORD_NCASE			0x02		</span><span class="cm">/**&lt; case insensitive comparison of VT_STRING data */</span><span class="cp"></span>
<span class="cp">	#define	ORD_NULLS_BEFORE	0x04		</span><span class="cm">/**&lt; NULLs are sorted before non-null data */</span><span class="cp"></span>
<span class="cp">	#define	ORD_NULLS_AFTER		0x08		</span><span class="cm">/**&lt; NULLS are sorted after non-null data */</span><span class="cp"></span>

	<span class="cm">/**</span>
<span class="cm">	 * Ordering segment specification</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">AFY_EXP</span> <span class="n">OrderSeg</span>
	<span class="p">{</span>
		<span class="n">IExprNode</span>	<span class="o">*</span><span class="n">expr</span><span class="p">;</span>					<span class="cm">/**&lt; ordering expression, must be NULL is pid is set */</span>
		<span class="n">PropertyID</span>	<span class="n">pid</span><span class="p">;</span>					<span class="cm">/**&lt; ordering property, must be STORE_INVALID_URIID if expr is not NULL */</span>
		<span class="kt">uint8_t</span>		<span class="n">flags</span><span class="p">;</span>					<span class="cm">/**&lt; bit flags (see ORD_XXX above) */</span>
		<span class="kt">uint8_t</span>		<span class="n">var</span><span class="p">;</span>					<span class="cm">/**&lt; in joins, variable number */</span>
		<span class="kt">uint16_t</span>	<span class="n">lPrefix</span><span class="p">;</span>				<span class="cm">/**&lt; prefix length to be used for comparisons of VT_STRING data */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Query variable identifier</span>
<span class="cm">	 */</span>
	<span class="k">typedef</span>	<span class="kt">unsigned</span>	<span class="kt">char</span>	<span class="n">QVarID</span><span class="p">;</span>
<span class="cp">	#define	INVALID_QVAR_ID		0xFF</span>

	<span class="cm">/**</span>
<span class="cm">	 * Type of statement</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">STMT_OP</span>
	<span class="p">{</span>
		<span class="n">STMT_QUERY</span><span class="p">,</span> <span class="n">STMT_INSERT</span><span class="p">,</span> <span class="n">STMT_UPDATE</span><span class="p">,</span> <span class="n">STMT_DELETE</span><span class="p">,</span> <span class="n">STMT_UNDELETE</span><span class="p">,</span> <span class="n">STMT_START_TX</span><span class="p">,</span> <span class="n">STMT_COMMIT</span><span class="p">,</span> <span class="n">STMT_ROLLBACK</span><span class="p">,</span> <span class="n">STMT_OP_ALL</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * DISTINCT type</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">DistinctType</span>
	<span class="p">{</span>
		<span class="n">DT_DEFAULT</span><span class="p">,</span> <span class="n">DT_ALL</span><span class="p">,</span> <span class="n">DT_DISTINCT</span><span class="p">,</span> <span class="n">DT_FIRST</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Statement execution callback for aynchronous query execution</span>
<span class="cm">	 * @see IStmt::asyncexec()</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IStmtCallback</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">result</span><span class="p">(</span><span class="n">ICursor</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span><span class="n">RC</span> <span class="n">rc</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Main query, DML and DDL statement interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IStmt</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span> <span class="n">QVarID</span>	<span class="n">addVariable</span><span class="p">(</span><span class="k">const</span> <span class="n">SourceSpec</span> <span class="o">*</span><span class="n">classes</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nClasses</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">cond</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; add varaible either for full scan (no SourceSpec specified) or for intersection of given calsses/families with optional condition */</span>
		<span class="k">virtual</span> <span class="n">QVarID</span>	<span class="n">addVariable</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">pid</span><span class="p">,</span><span class="n">PropertyID</span> <span class="n">propID</span><span class="p">,</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">cond</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; add collection scanning variable */</span>
		<span class="k">virtual</span> <span class="n">QVarID</span>	<span class="n">addVariable</span><span class="p">(</span><span class="n">IStmt</span> <span class="o">*</span><span class="n">qry</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; add sub-query variable (e.g. nested SELECT in FROM */</span>
		<span class="k">virtual</span>	<span class="n">QVarID</span>	<span class="n">setOp</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">leftVar</span><span class="p">,</span><span class="n">QVarID</span> <span class="n">rightVar</span><span class="p">,</span><span class="n">QUERY_SETOP</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; add set operation (QRY_UNION, QRY_INTERSECT, QRY_EXCEPT) variable for 2 sub-variables*/</span>
		<span class="k">virtual</span>	<span class="n">QVarID</span>	<span class="n">setOp</span><span class="p">(</span><span class="k">const</span> <span class="n">QVarID</span> <span class="o">*</span><span class="n">vars</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVars</span><span class="p">,</span><span class="n">QUERY_SETOP</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; add set operation (QRY_UNION, QRY_INTERSECT, QRY_EXCEPT) variable for multiple sub-variables*/</span>
		<span class="k">virtual</span>	<span class="n">QVarID</span>	<span class="n">join</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">leftVar</span><span class="p">,</span><span class="n">QVarID</span> <span class="n">rightVar</span><span class="p">,</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">cond</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="n">QUERY_SETOP</span><span class="o">=</span><span class="n">QRY_SEMIJOIN</span><span class="p">,</span><span class="n">PropertyID</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; set join variable for 2 sub-variables with optional condition */</span>
		<span class="k">virtual</span>	<span class="n">QVarID</span>	<span class="n">join</span><span class="p">(</span><span class="k">const</span> <span class="n">QVarID</span> <span class="o">*</span><span class="n">vars</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVars</span><span class="p">,</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">cond</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="n">QUERY_SETOP</span><span class="o">=</span><span class="n">QRY_SEMIJOIN</span><span class="p">,</span><span class="n">PropertyID</span><span class="o">=</span><span class="n">STORE_INVALID_URIID</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; set join variable for multiple sub-variables with optional condition */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setName</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; set variable name string to be used in query rendering (i.e. FROM ... AS name ) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setDistinct</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="n">DistinctType</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; set DISTINCT mode for a variable */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">addOutput</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">dscr</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nDscr</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; add output descriptior */</span>
		<span class="k">virtual</span> <span class="n">RC</span>		<span class="n">addCondition</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">cond</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; add a condition (part of WHERE clause); multiple conditions are AND-ed */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">addConditionFT</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">PropertyID</span> <span class="o">*</span><span class="n">pids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPids</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; add free-text search string and optional property filter for a simple variable */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setPIDs</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="n">PID</span> <span class="o">*</span><span class="n">pids</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPids</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; set PIN ID array filter for a simple (not-join, not-set) variable */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setPath</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="n">PathSeg</span> <span class="o">*</span><span class="n">segs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSegs</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; set path expression for a simple variable */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setExpr</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">exp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; set a generic expression for a simple variable */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setPropCondition</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="n">PropertyID</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProps</span><span class="p">,</span><span class="n">bool</span> <span class="n">fOr</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; set property existence condition, i.e. EXISTS(prop1) AND EXISTS(prop2) ... */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setJoinProperties</span><span class="p">(</span><span class="n">QVarID</span> <span class="n">var</span><span class="p">,</span><span class="k">const</span> <span class="n">PropertyID</span> <span class="o">*</span><span class="n">props</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProps</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; set properties for natural join or USING(...) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setGroup</span><span class="p">(</span><span class="n">QVarID</span><span class="p">,</span><span class="k">const</span> <span class="n">OrderSeg</span> <span class="o">*</span><span class="n">order</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSegs</span><span class="p">,</span><span class="n">IExprNode</span> <span class="o">*</span><span class="n">having</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>				<span class="cm">/**&lt; set GROUP BY clause */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setOrder</span><span class="p">(</span><span class="k">const</span> <span class="n">OrderSeg</span> <span class="o">*</span><span class="n">order</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSegs</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; set statement-wide result ordering */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">setValues</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="k">const</span> <span class="n">IntoClass</span> <span class="o">*</span><span class="n">into</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nInto</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="n">tid</span><span class="o">=</span><span class="mi">0ULL</span><span class="p">)</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; set Value structures, class filter and PIN flags for STMT_INSERT and STMT_UPDATE statements */</span>

		<span class="k">virtual</span>	<span class="n">STMT_OP</span>	<span class="n">getOp</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																										<span class="cm">/**&lt; get statement type */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">execute</span><span class="p">(</span><span class="n">ICursor</span> <span class="o">**</span><span class="n">result</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProcess</span><span class="o">=~</span><span class="mi">0u</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>		<span class="cm">/**&lt; execute statement, return result set iterator or number of affected PINs */</span>
										<span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="n">nProcessed</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="n">TXI_LEVEL</span><span class="o">=</span><span class="n">TXI_DEFAULT</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">asyncexec</span><span class="p">(</span><span class="n">IStmtCallback</span> <span class="o">*</span><span class="n">cb</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProcess</span><span class="o">=~</span><span class="mi">0u</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>			<span class="cm">/**&lt; execute statement asynchronously */</span>
										<span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">TXI_LEVEL</span><span class="o">=</span><span class="n">TXI_DEFAULT</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">execute</span><span class="p">(</span><span class="n">IStreamOut</span><span class="o">*&amp;</span> <span class="n">result</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProcess</span><span class="o">=~</span><span class="mi">0u</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>			<span class="cm">/**&lt; execute statement, return results as a protobuf stream */</span>
										<span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">TXI_LEVEL</span><span class="o">=</span><span class="n">TXI_DEFAULT</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">count</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">&amp;</span> <span class="n">cnt</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nAbort</span><span class="o">=~</span><span class="mi">0u</span><span class="p">,</span>									<span class="cm">/**&lt; count statement results */</span>
										<span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">TXI_LEVEL</span><span class="o">=</span><span class="n">TXI_DEFAULT</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">exist</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">TXI_LEVEL</span><span class="o">=</span><span class="n">TXI_DEFAULT</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; check if any PINs satfisfy query conditions */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">analyze</span><span class="p">(</span><span class="kt">char</span> <span class="o">*&amp;</span><span class="n">plan</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">pars</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPars</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">md</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; return execution plan for the statement */</span>

		<span class="k">virtual</span>	<span class="n">bool</span>	<span class="n">isSatisfied</span><span class="p">(</span><span class="k">const</span> <span class="n">IPIN</span> <span class="o">*</span><span class="n">pin</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">pars</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPars</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; check if a given PIN satisfies query conditions */</span>
		<span class="k">virtual</span>	<span class="kt">char</span>	<span class="o">*</span><span class="n">toString</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">QName</span> <span class="o">*</span><span class="n">qNames</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nQNames</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; convert statement to PathSQL string */</span>

		<span class="k">virtual</span>	<span class="n">IStmt</span>	<span class="o">*</span><span class="n">clone</span><span class="p">(</span><span class="n">STMT_OP</span><span class="o">=</span><span class="n">STMT_OP_ALL</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>															<span class="cm">/**&lt; clone IStmt object */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																					<span class="cm">/**&lt; destroy IStmt object */</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * Event types in event specifications</span>
<span class="cm">	 * @see EventSpec</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">EvType</span>
	<span class="p">{</span>
		<span class="n">EvNone</span><span class="p">,</span>								<span class="cm">/**&lt; no-event (for use in FSMs) */</span>
		<span class="n">EvClass</span><span class="p">,</span>							<span class="cm">/**&lt; class event */</span>
		<span class="n">EvProp</span><span class="p">,</span>								<span class="cm">/**&lt; property modification */</span>
		<span class="n">EvTime</span><span class="p">,</span>								<span class="cm">/**&lt; interval expiration */</span>
		<span class="n">EvExt</span><span class="p">,</span>								<span class="cm">/**&lt; external I/O events reported by various listeners */</span>
		<span class="n">EvSubs</span><span class="p">,</span>								<span class="cm">/**&lt; events related to generic subscription topics, e.g. in publish/subscribe protocols */</span>
		<span class="n">EvMask</span>			<span class="o">=</span><span class="mh">0x0FFF</span><span class="p">,</span>			<span class="cm">/**&lt; basic event type mask */</span>
		<span class="n">EvLeave</span>			<span class="o">=</span><span class="mh">0x2000</span><span class="p">,</span>			<span class="cm">/**&lt; bit: instance or property is removed */</span>
		<span class="n">EvUpdate</span>		<span class="o">=</span><span class="mh">0x4000</span><span class="p">,</span>			<span class="cm">/**&lt; bit: instance or property is modified */</span>
		<span class="n">EvNew</span>			<span class="o">=</span><span class="mh">0x8000</span><span class="p">,</span>			<span class="cm">/**&lt; bit: instance or property is added */</span>
	<span class="p">};</span>
	 
	<span class="cm">/**</span>
<span class="cm">	 * bits for EventSpec::flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define	EV_LAST_ELEMENT		0x01		</span><span class="cm">/**&lt; with EvProp - last element of collection */</span><span class="cp"></span>
<span class="cp">	#define	EV_FIRST_ELEMENT	0x02		</span><span class="cm">/**&lt; with EvProp - first element of collection */</span><span class="cp"></span>
<span class="cp">	#define	EV_DROP_FIRST_EVENT	0x04		</span><span class="cm">/**&lt; when event queue overflows - drop first rather than last element */</span><span class="cp"></span>
<span class="cp">	#define	EV_EXIT				0x08		</span><span class="cm">/**&lt; exit event handler/FSM */</span><span class="cp"></span>
	 
	<span class="cm">/**</span>
<span class="cm">	 * Event specification</span>
<span class="cm">	 * fits into uint64_t and stored as VT_UINT64 in PROP_SPEC_EVENT</span>
<span class="cm">	 */</span>
	<span class="k">union</span> <span class="n">EventSpec</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">uint16_t</span>		<span class="n">evType</span><span class="p">;</span>
			<span class="kt">uint8_t</span>			<span class="n">nQEvents</span><span class="p">;</span>
			<span class="kt">uint8_t</span>			<span class="n">flags</span><span class="p">;</span>
			<span class="k">union</span> <span class="p">{</span>
				<span class="n">URIID</span>		<span class="n">uid</span><span class="p">;</span>
				<span class="kt">uint32_t</span>	<span class="n">itv</span><span class="p">;</span>
			<span class="p">};</span>
		<span class="p">};</span>
		<span class="kt">uint64_t</span>			<span class="n">u64</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">struct</span> <span class="n">ActionDescriptor</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">nActions</span><span class="p">;</span>
		<span class="n">bool</span>		<span class="n">fOnce</span><span class="p">;</span>
		<span class="n">IStmt</span>		<span class="o">*</span><span class="n">actions</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Full identification of properties.</span>
<span class="cm">	 * @see ISession::mapURIs()</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">URIMap</span>
	<span class="p">{</span>
		<span class="k">const</span>		<span class="kt">char</span>	<span class="o">*</span><span class="n">URI</span><span class="p">;</span>
		<span class="n">URIID</span>				<span class="n">uid</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * PIN page allocation control structure</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">AllocCtrl</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span>	<span class="n">arrayThreshold</span><span class="p">;</span>
		<span class="kt">size_t</span>		<span class="n">ssvThreshold</span><span class="p">;</span>
		<span class="kt">float</span>		<span class="n">pctPageFree</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Index navigator</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">IndexNav</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">next</span><span class="p">(</span><span class="n">PID</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">,</span><span class="n">GO_DIR</span><span class="o">=</span><span class="n">GO_NEXT</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">position</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">pv</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">getValue</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*&amp;</span><span class="n">pv</span><span class="p">,</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">nValues</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="k">const</span> <span class="n">Value</span>	<span class="o">*</span><span class="n">next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Free-text index scanning interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">StringEnum</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="k">const</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * map element declaration </span>
<span class="cm">	 * @see ISession::createMap()</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">MapElt</span>
	<span class="p">{</span>
		<span class="n">Value</span>	<span class="n">key</span><span class="p">;</span>
		<span class="n">Value</span>	<span class="n">val</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * trace interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">ITrace</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">trace</span><span class="p">(</span><span class="kt">long</span> <span class="n">code</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="kt">va_list</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * PIN batch insert interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">IBatch</span> <span class="o">:</span> <span class="n">public</span> <span class="n">IMemAlloc</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getNumberOfPINs</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>															<span class="cm">/**&lt; get number of PINs in the batch */</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">getSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; get current batch size in memory */</span>
		<span class="k">virtual</span>	<span class="n">Value</span>		<span class="o">*</span><span class="n">createValues</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">nValues</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; Value array creation helper */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createPIN</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">PID</span> <span class="o">*</span><span class="n">original</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/**&lt; create a PIN in the batch */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">addRef</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">to</span><span class="p">,</span><span class="n">bool</span> <span class="n">fAdd</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; add a reference from &#39;from&#39; PIN to &#39;to&#39; PIN (PIN id, PIN * or index in the batch) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">clone</span><span class="p">(</span><span class="n">IPIN</span> <span class="o">*</span><span class="n">pin</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; clone a pin into this batch */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">process</span><span class="p">(</span><span class="n">bool</span> <span class="n">fDestroy</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">AllocCtrl</span><span class="o">*</span> <span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="k">const</span> <span class="n">IntoClass</span> <span class="o">*</span><span class="n">into</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nInto</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; insert all batched PINs (and optionally destroy the batch) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getPIDs</span><span class="p">(</span><span class="n">PID</span> <span class="o">*</span><span class="n">pids</span><span class="p">,</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">nPIDs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; return PIN ids after call to process */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getPID</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span><span class="n">PID</span><span class="o">&amp;</span> <span class="n">pid</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; return PIN id after call to process (by PIN index) */</span>
		<span class="k">virtual</span>	<span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">getProperty</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span><span class="p">,</span><span class="n">URIID</span> <span class="n">pid</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; return PIN property (by PIN index) */</span>
		<span class="k">virtual</span>	<span class="n">ElementID</span>	<span class="n">getEIDBase</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; return base number used to generate element ids in collections */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																			<span class="cm">/**&lt; destroy the batch */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * The session encapsulates a client&#39;s connection to the store.</span>
<span class="cm">	 * Through it, the client can create, query, modify and delete PINs,</span>
<span class="cm">	 * in a transactioned manner.  This is also where the client</span>
<span class="cm">	 * can map PropIDs to full property information (e.g. names).</span>
<span class="cm">	 * Note:</span>
<span class="cm">	 *  A command executed outside a transaction is implicitly</span>
<span class="cm">	 *  executed in its own transaction.</span>
<span class="cm">	 * @see IPIN</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">ISession</span> <span class="o">:</span> <span class="n">public</span> <span class="n">IMemAlloc</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">class</span> <span class="n">IAffinity</span>	<span class="o">*</span><span class="n">getAffinity</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; retrieve store context */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">freeMemory</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; free ISession memory; all objects are discarded */</span>							
		<span class="k">virtual</span>	<span class="n">ISession</span>	<span class="o">*</span><span class="n">clone</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; clone existing session */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">attachToCurrentThread</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; in server: attach ISession to current worker thread (ISession can be accessed concurrently only from one thread */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">detachFromCurrentThread</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; in server: detach ISession from current worker thread */</span>

		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">setInterfaceMode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; set interface mode, see ITF_XXX flags above */</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getInterfaceMode</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; get current interface mode */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">setDefaultExpiration</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">defExp</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; set default expiration time for cached remore PINs */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">changeTraceMode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mask</span><span class="p">,</span><span class="n">bool</span> <span class="n">fReset</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; change trace mode, see TRACE_XXX flags above  */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">setTrace</span><span class="p">(</span><span class="n">ITrace</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																<span class="cm">/**&lt; set query execution trace interface */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">terminate</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; terminate session; drops the session */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">mapURIs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">nURIs</span><span class="p">,</span><span class="n">URIMap</span> <span class="n">URIs</span><span class="p">[],</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">URIBase</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="n">bool</span> <span class="n">fObj</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; maps URI strings to their internal URIID values used throughout the interface */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getURI</span><span class="p">(</span><span class="n">URIID</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">lbuf</span><span class="p">,</span><span class="n">bool</span> <span class="n">fFull</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; get URI string by its URIID value; if buf==NULL return URI string length */</span>

		<span class="k">virtual</span>	<span class="n">IdentityID</span>	<span class="n">getCurrentIdentityID</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; get the identity the current session is running with */</span>
		<span class="k">virtual</span>	<span class="n">IdentityID</span>	<span class="n">getIdentityID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; get ID for an identity; the identity must be stored by calling storeIdentity() */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">impersonate</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; this session impresonates given identity; can be called only for OWNER sessions */</span>
		<span class="k">virtual</span>	<span class="n">IdentityID</span>	<span class="n">storeIdentity</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pwd</span><span class="p">,</span><span class="n">bool</span> <span class="n">fMayInsert</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cert</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">lcert</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; store identity information, including password, insert permission, optional certificate */</span>
		<span class="k">virtual</span>	<span class="n">IdentityID</span>	<span class="n">loadIdentity</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identity</span><span class="p">,</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pwd</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">lPwd</span><span class="p">,</span><span class="n">bool</span> <span class="n">fMayInsert</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cert</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">lcert</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/**&lt; load identity information */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">setInsertPermission</span><span class="p">(</span><span class="n">IdentityID</span><span class="p">,</span><span class="n">bool</span> <span class="n">fMayInsert</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; set insert premission for existing identity */</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">getStoreIdentityName</span><span class="p">(</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[],</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; get identity name of the store owner */</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">getIdentityName</span><span class="p">(</span><span class="n">IdentityID</span><span class="p">,</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[],</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; get identity name for a stored identity */</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">getCertificate</span><span class="p">(</span><span class="n">IdentityID</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[],</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; get identity certificate, if any */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">changePassword</span><span class="p">(</span><span class="n">IdentityID</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldPwd</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newPwd</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>				<span class="cm">/**&lt; change identity password */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">changeCertificate</span><span class="p">(</span><span class="n">IdentityID</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pwd</span><span class="p">,</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cert</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">lcert</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; change identity certificate */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">changeStoreIdentity</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newIdentity</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; change identity of the store owner */</span>

		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getStoreID</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; get ID (number from 0 t0 65535) of store the PIN with this ID was created in */</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getLocalStoreID</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																<span class="cm">/**&lt; get ID of this store */</span>

		<span class="k">virtual</span>	<span class="n">IExprNode</span>	<span class="o">*</span><span class="n">expr</span><span class="p">(</span><span class="n">ExprOp</span> <span class="n">op</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nOperands</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; create expression tree node */</span>

		<span class="k">virtual</span>	<span class="n">IStmt</span>		<span class="o">*</span><span class="n">createStmt</span><span class="p">(</span><span class="n">STMT_OP</span><span class="o">=</span><span class="n">STMT_QUERY</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; create IStmt object */</span>
		<span class="k">virtual</span>	<span class="n">IStmt</span>		<span class="o">*</span><span class="n">createStmt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">queryStr</span><span class="p">,</span><span class="k">const</span> <span class="n">URIID</span> <span class="o">*</span><span class="n">ids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nids</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">CompilationError</span> <span class="o">*</span><span class="n">ce</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; create IStmt from PathSQL string */</span>
		<span class="k">virtual</span>	<span class="n">IExprNode</span>	<span class="o">*</span><span class="n">createExprTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="k">const</span> <span class="n">URIID</span> <span class="o">*</span><span class="n">ids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nids</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">CompilationError</span> <span class="o">*</span><span class="n">ce</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; create expression tree from PathSQL string */</span>
		<span class="k">virtual</span>	<span class="n">IExpr</span>		<span class="o">*</span><span class="n">createExpr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="k">const</span> <span class="n">URIID</span> <span class="o">*</span><span class="n">ids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nids</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">CompilationError</span> <span class="o">*</span><span class="n">ce</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; create compiled expression from PathSQL string */</span>
		<span class="k">virtual</span>	<span class="n">IExpr</span>		<span class="o">*</span><span class="n">createExtExpr</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">langID</span><span class="p">,</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">body</span><span class="p">,</span><span class="kt">uint32_t</span> <span class="n">lBody</span><span class="p">,</span><span class="kt">uint16_t</span> <span class="n">flags</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; create &#39;external expression&#39; for loadable language libraries */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getTypeName</span><span class="p">(</span><span class="n">ValueType</span> <span class="n">type</span><span class="p">,</span><span class="kt">char</span> <span class="n">buf</span><span class="p">[],</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">abortQuery</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">execute</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">lstr</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">result</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="k">const</span> <span class="n">URIID</span> <span class="o">*</span><span class="n">ids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nids</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>			<span class="cm">/**&lt; execute query specified by PathSQL string; return result in JSON form */</span>
									<span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">CompilationError</span> <span class="o">*</span><span class="n">ce</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="n">nProcessed</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span>
									<span class="kt">unsigned</span> <span class="n">nProcess</span><span class="o">=~</span><span class="mi">0u</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSkip</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createInputStream</span><span class="p">(</span><span class="n">IStreamIn</span> <span class="o">*&amp;</span><span class="n">in</span><span class="p">,</span><span class="n">IStreamIn</span> <span class="o">*</span><span class="n">out</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; create protobuf input stream interface */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createServiceCtx</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVals</span><span class="p">,</span><span class="n">class</span> <span class="n">IServiceCtx</span> <span class="o">*&amp;</span><span class="n">sctx</span><span class="p">,</span><span class="n">bool</span> <span class="n">fWrite</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span><span class="n">class</span> <span class="n">IListener</span> <span class="o">*</span><span class="n">lctx</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/**&lt; create IServiceCtx from provided parameters */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getClassID</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">className</span><span class="p">,</span><span class="n">ClassID</span><span class="o">&amp;</span> <span class="n">cid</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; get ClassID for gived class URI; equivalent to mapURIs() but check class existence */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">enableClassNotifications</span><span class="p">(</span><span class="n">ClassID</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">notifications</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; enables notifications for a given class, see CLASS_NOTIFY_XXX above */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">rebuildIndices</span><span class="p">(</span><span class="k">const</span> <span class="n">ClassID</span> <span class="o">*</span><span class="n">cidx</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nClasses</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; rebuild all DB indices (except free-text index) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">rebuildIndexFT</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																<span class="cm">/**&lt; rebuild free-text index */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createIndexNav</span><span class="p">(</span><span class="n">ClassID</span><span class="p">,</span><span class="n">IndexNav</span> <span class="o">*&amp;</span><span class="n">nav</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; create IndexNav object */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">listValues</span><span class="p">(</span><span class="n">ClassID</span> <span class="n">cid</span><span class="p">,</span><span class="n">PropertyID</span> <span class="n">pid</span><span class="p">,</span><span class="n">IndexNav</span> <span class="o">*&amp;</span><span class="n">ven</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; list all stored values for a given class family */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">listWords</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">query</span><span class="p">,</span><span class="n">StringEnum</span> <span class="o">*&amp;</span><span class="n">sen</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; list all words in FT index matching given prefix or list of words */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getClassInfo</span><span class="p">(</span><span class="n">ClassID</span><span class="p">,</span><span class="n">IPIN</span><span class="o">*&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; get class information */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">allocPIN</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">maxSize</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nProps</span><span class="p">,</span><span class="n">IPIN</span> <span class="o">*&amp;</span><span class="n">pin</span><span class="p">,</span><span class="n">Value</span> <span class="o">*&amp;</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; fast allocate space for a PIN which can be passed between sessions, up to 64K (for use in services mainly) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">inject</span><span class="p">(</span><span class="n">IPIN</span> <span class="o">*</span><span class="n">pin</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																<span class="cm">/**&lt; inject a new PIN into the system triggering various events */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createEventHandler</span><span class="p">(</span><span class="k">const</span> <span class="n">EventSpec</span> <span class="n">evdesc</span><span class="p">[],</span><span class="kt">unsigned</span> <span class="n">nDesc</span><span class="p">,</span><span class="n">RC</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="cm">/*???*/</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/**&lt; create an event handler with a callback function (normally used by services) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createEventHandler</span><span class="p">(</span><span class="k">const</span> <span class="n">EventSpec</span> <span class="n">evdesc</span><span class="p">[],</span><span class="kt">unsigned</span> <span class="n">nDesc</span><span class="p">,</span><span class="n">ActionDescriptor</span><span class="p">[])</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/**&lt; create an event handler defined by an array of ActionDescrition structures */</span>

		<span class="k">virtual</span>	<span class="n">IPIN</span>		<span class="o">*</span><span class="n">getPIN</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; retrieve a PIN by its ID */</span>
		<span class="k">virtual</span>	<span class="n">IPIN</span>		<span class="o">*</span><span class="n">getPIN</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; retrive a PIN by its reference in a Value */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getValue</span><span class="p">(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">,</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">,</span><span class="n">PropertyID</span><span class="p">,</span><span class="n">ElementID</span><span class="o">=</span><span class="n">STORE_COLLECTION_ID</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; get property value for a value reference */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">getPINClasses</span><span class="p">(</span><span class="n">ClassID</span> <span class="o">*&amp;</span><span class="n">clss</span><span class="p">,</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">nclss</span><span class="p">,</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; array of ClassIDs the PIN is a member of */</span>
		<span class="k">virtual</span>	<span class="n">bool</span>		<span class="n">isCached</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; check if a PIN is in remote PIN cache by its ID */</span>
		<span class="k">virtual</span>	<span class="n">IBatch</span>		<span class="o">*</span><span class="n">createBatch</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; create PIN batch insert interface */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createPIN</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="n">IPIN</span> <span class="o">**</span><span class="n">result</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">PID</span> <span class="o">*</span><span class="n">original</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/**&lt; create a PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">modifyPIN</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span><span class="o">&amp;</span> <span class="n">id</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">ElementID</span> <span class="o">*</span><span class="n">eids</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">pNFailed</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; modify committed or uncommitted PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">deletePINs</span><span class="p">(</span><span class="n">IPIN</span> <span class="o">**</span><span class="n">pins</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPins</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; (soft-)delete or purge committed PINs from persistent memory */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">deletePINs</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span> <span class="o">*</span><span class="n">pids</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPids</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; (soft-)delete or purge committed PINs from persistent memory by their IDs */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">undeletePINs</span><span class="p">(</span><span class="k">const</span> <span class="n">PID</span> <span class="o">*</span><span class="n">pids</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPids</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; undelete soft-deleted PINs */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">startTransaction</span><span class="p">(</span><span class="n">TX_TYPE</span><span class="o">=</span><span class="n">TXT_READWRITE</span><span class="p">,</span><span class="n">TXI_LEVEL</span><span class="o">=</span><span class="n">TXI_DEFAULT</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; start transaction, READ-ONLY or READ_WRITE */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">commit</span><span class="p">(</span><span class="n">bool</span> <span class="n">fAll</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; commit transaction */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">rollback</span><span class="p">(</span><span class="n">bool</span> <span class="n">fAll</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; rollback (abort) transaction */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">setLimits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">xSyncStack</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">xOnCommit</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; set transaction guard limits */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">reservePages</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nPages</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; used in dump/load entire store */</span>

		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createMap</span><span class="p">(</span><span class="k">const</span> <span class="n">MapElt</span> <span class="o">*</span><span class="n">elts</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nElts</span><span class="p">,</span><span class="n">IMap</span> <span class="o">*&amp;</span><span class="n">map</span><span class="p">,</span><span class="n">bool</span> <span class="n">fCopy</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; create a map (VT_MAP type) */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">copyValue</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">dest</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; copy Value to session memory */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">copyValues</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="n">Value</span> <span class="o">*&amp;</span><span class="n">dest</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; copy an array of Value structures to session memory */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">convertValue</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">oldValue</span><span class="p">,</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">newValue</span><span class="p">,</span><span class="n">ValueType</span> <span class="n">newType</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; convert Value type */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">parseValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">l</span><span class="p">,</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">,</span><span class="n">CompilationError</span> <span class="o">*</span><span class="n">ce</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; parse a string to Value */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">parseValues</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">l</span><span class="p">,</span><span class="n">Value</span> <span class="o">*&amp;</span><span class="n">res</span><span class="p">,</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">nValues</span><span class="p">,</span><span class="n">CompilationError</span> <span class="o">*</span><span class="n">ce</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">char</span> <span class="n">delimiter</span><span class="o">=</span><span class="sc">&#39;,&#39;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; parse a string containing multiple values in PathSQL format */</span>
		<span class="k">virtual</span>	<span class="kt">int</span>			<span class="n">compareValues</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">,</span><span class="n">bool</span> <span class="n">fNCase</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>				<span class="cm">/**&lt; compare 2 Values (can be of different types) */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">freeValues</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVals</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; free an array of Value structures allocated in session memory */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">freeValue</span><span class="p">(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>															<span class="cm">/**&lt; free a Value structure with data allocation in session memory */</span>

		<span class="k">virtual</span>	<span class="kt">char</span>		<span class="o">*</span><span class="n">convToJSON</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; convert a value to JSON representation */</span>

		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">setTimeZone</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">tzShift</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; set session time zone */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">convDateTime</span><span class="p">(</span><span class="n">TIMESTAMP</span> <span class="n">dt</span><span class="p">,</span><span class="n">DateTime</span><span class="o">&amp;</span> <span class="n">dts</span><span class="p">,</span><span class="n">bool</span> <span class="n">fUTC</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; convert timestamp from internal representation to DateTiem structure */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">convDateTime</span><span class="p">(</span><span class="k">const</span> <span class="n">DateTime</span><span class="o">&amp;</span> <span class="n">dts</span><span class="p">,</span><span class="n">TIMESTAMP</span><span class="o">&amp;</span> <span class="n">dt</span><span class="p">,</span><span class="n">bool</span> <span class="n">fUTC</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; convert tiemstamp from DateTime to internal representation */</span>

		<span class="k">virtual</span>	<span class="kt">uint64_t</span>	<span class="n">getCodeTrace</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																	<span class="cm">/**&lt; used for performance Affinity tracing */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Service interface flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define	ISRV_ENDPOINT		0x00000001		</span><span class="cm">/**&lt; end-point service (can be in the middle of the stack) */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_READ			0x00000002		</span><span class="cm">/**&lt; read stack service */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_WRITE			0x00000004		</span><span class="cm">/**&lt; write stack service */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_SERVER			0x00000008		</span><span class="cm">/**&lt; server service: processes request and returns result to be passed back to caller */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_REQUEST		0x00000010		</span><span class="cm">/**&lt; request parsing or rendering */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_RESPONSE		0x00000020		</span><span class="cm">/**&lt; response parsing or rendering */</span><span class="cp"></span>

<span class="cp">	#define	ISRV_ALLOCBUF		0x00000100		</span><span class="cm">/**&lt; output buffer to be allocated before call to invoke() */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_NOCACHE		0x00000200		</span><span class="cm">/**&lt; service processor cannot be cached between calls */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_ENVELOPE		0x00000400		</span><span class="cm">/**&lt; service augments a buffer with a header and/or trailer */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_TRANSIENT		0x00000800		</span><span class="cm">/**&lt; transient listener: one event only */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_ERROR			0x00001000		</span><span class="cm">/**&lt; service can report an error to the client */</span><span class="cp"></span>
	
	<span class="cm">/**</span>
<span class="cm">	 * IService::Processor::invoke() &#39;mode&#39; parameter flags</span>
<span class="cm">	 */</span>
<span class="cp">	#define	ISRV_NEEDMORE		0x00010000		</span><span class="cm">/**&lt; need more input to finish output */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_APPEND			0x00020000		</span><span class="cm">/**&lt; append data to previous buffer */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_NEEDFLUSH		0x00040000		</span><span class="cm">/**&lt; a service has output which needs to be flushed */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_REFINP			0x00080000		</span><span class="cm">/**&lt; output refers to input (buffer or Value) */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_MOREOUT		0x00100000		</span><span class="cm">/**&lt; continue processing input/partially processed input */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_KEEPINP		0x00200000		</span><span class="cm">/**&lt; keep input; call with the same input again */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_CONSUMED		0x00400000		</span><span class="cm">/**&lt; buffer is stored (usually write endpoint); don&#39;t use it anymore */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_WAIT			0x00800000		</span><span class="cm">/**&lt; endpoint: wait for read operation to return data or for write operation to finish */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_EOM			0x01000000		</span><span class="cm">/**&lt; end-of-message marker encountered on read or needs to be added on write */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_FLUSH			0x02000000		</span><span class="cm">/**&lt; flush marker encountered in a stream */</span><span class="cp"></span>
<span class="cp">	#define	ISRV_SKIP			0x04000000		</span><span class="cm">/**&lt; skip this service when processing more data */</span><span class="cp"></span>

<span class="cp">	#define	ISRV_PROC_MASK		(ISRV_ENDPOINT|ISRV_READ|ISRV_WRITE)</span>
<span class="cp">	#define	ISRV_PROC_MODE		(ISRV_PROC_MASK|ISRV_REQUEST|ISRV_RESPONSE|ISRV_ALLOCBUF|ISRV_NOCACHE|ISRV_ENVELOPE|ISRV_TRANSIENT|ISRV_ERROR|ISRV_WAIT)</span>

	<span class="cm">/**</span>
<span class="cm">	 * types of service errors</span>
<span class="cm">	 */</span>
	<span class="k">enum</span> <span class="n">ServiceErrorType</span>
	<span class="p">{</span>
		<span class="n">SET_COMM</span><span class="p">,</span>				<span class="cm">/**&lt; communication error reported by endpoint, e.g. connection reset, access denied etc. */</span>
		<span class="n">SET_FORM</span><span class="p">,</span>				<span class="cm">/**&lt; malformed request or response */</span>
		<span class="n">SET_AUTH</span><span class="p">,</span>				<span class="cm">/**&lt; authentication error, e.g. incorrectly signed message */</span>
		<span class="n">SET_MISMATCH</span><span class="p">,</span>			<span class="cm">/**&lt; mismatched request-response token */</span>
		<span class="n">SET_REMOTE</span><span class="p">,</span>				<span class="cm">/**&lt; well-formed response containing remote error information, e.g. HTTP 3XX-5XX codes */</span>
		<span class="n">SET_LOCAL</span>				<span class="cm">/**&lt; incorrect data passed by the local program, e.g. missing property, incorrect property type or value */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * result allocator interface for structured output</span>
<span class="cm">	 * used by services to allocate memory for results returned from invoke()</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">IResAlloc</span> <span class="o">:</span> <span class="n">public</span> <span class="n">IMemAlloc</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">Value</span>		<span class="o">*</span><span class="n">createValues</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">nValues</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; Value array creation helper */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">createPIN</span><span class="p">(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">,</span><span class="n">Value</span> <span class="o">*</span><span class="n">values</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nValues</span><span class="p">,</span><span class="k">const</span> <span class="n">PID</span> <span class="o">*</span><span class="n">id</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; create a result PIN */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Service stack invocation context</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IServiceCtx</span> <span class="o">:</span> <span class="n">public</span> <span class="n">IMemAlloc</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>				<span class="n">invoke</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVals</span><span class="p">,</span><span class="n">Value</span> <span class="o">*</span><span class="n">res</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; invoke services in this context */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">error</span><span class="p">(</span><span class="n">ServiceErrorType</span> <span class="n">etype</span><span class="p">,</span><span class="n">RC</span> <span class="n">rc</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">info</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; service calls to report an error */</span>
		<span class="k">virtual</span>	<span class="n">ISession</span>		<span class="o">*</span><span class="n">getSession</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; get current session */</span>
		<span class="k">virtual</span>	<span class="k">const</span>	<span class="n">Value</span>	<span class="o">*</span><span class="n">getParameter</span><span class="p">(</span><span class="n">URIID</span> <span class="n">prop</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>							<span class="cm">/**&lt; get parameter of this service invokation */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">getParameters</span><span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVals</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; get parameters of the stack invocation */</span>
		<span class="k">virtual</span>	<span class="n">IResAlloc</span>		<span class="o">*</span><span class="n">getResAlloc</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; return allocator interface for structured results */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>				<span class="n">expandBuffer</span><span class="p">(</span><span class="n">Value</span><span class="o">&amp;</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">extra</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; expand output buffer */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">releaseBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; return &#39;consumed&#39; buffer for reuse */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">setReadMode</span><span class="p">(</span><span class="n">bool</span> <span class="n">fWait</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>									<span class="cm">/**&lt; set endpoint read mode: wait/nowait */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">setKeepalive</span><span class="p">(</span><span class="n">bool</span> <span class="n">fSet</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; set keep-alive mode for connection-based network protocols */</span>
		<span class="k">virtual</span>	<span class="n">URIID</span>			<span class="n">getEndpointID</span><span class="p">(</span><span class="n">bool</span> <span class="n">fOut</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; returns endpoint URIID for this context (if any); fOut=true is used for ISRV_SERVER contexts, when output endpoint is different */</span>
		<span class="k">virtual</span>	<span class="n">IPIN</span>			<span class="o">*</span><span class="n">getCtxPIN</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; get context PIN */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>				<span class="n">getOSError</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; get OS specific error and convert to RC code */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>			<span class="n">destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; destroy this service context after use */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Abstract address encapsulation interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IAddress</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">bool</span> <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">IAddress</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; equality comparison */</span>
		<span class="k">virtual</span>	<span class="kt">int</span>	<span class="n">cmp</span><span class="p">(</span><span class="k">const</span> <span class="n">IAddress</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; -1,0,+1 for ordered structures */</span>
		<span class="k">virtual</span>	<span class="n">operator</span> <span class="kt">uint32_t</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>						<span class="cm">/**&lt; hash function for hash tables */</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Service interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IService</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">Processor</span> <span class="p">{</span>
		<span class="nl">public:</span>
			<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">connect</span><span class="p">(</span><span class="n">IServiceCtx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
			<span class="k">virtual</span>	<span class="n">RC</span>		<span class="n">invoke</span><span class="p">(</span><span class="n">IServiceCtx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">inp</span><span class="p">,</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">mode</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">virtual</span>	<span class="kt">void</span>	<span class="n">cleanup</span><span class="p">(</span><span class="n">IServiceCtx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="n">bool</span> <span class="n">fDestroying</span><span class="p">);</span>
		<span class="p">};</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">create</span><span class="p">(</span><span class="n">IServiceCtx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="kt">uint32_t</span><span class="o">&amp;</span> <span class="n">dscr</span><span class="p">,</span><span class="n">Processor</span> <span class="o">*&amp;</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">listen</span><span class="p">(</span><span class="n">ISession</span> <span class="o">*</span><span class="n">ses</span><span class="p">,</span><span class="n">URIID</span> <span class="n">id</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">params</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nParams</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">srvParams</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSrvparams</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span><span class="n">class</span> <span class="n">IListener</span> <span class="o">*&amp;</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">resolve</span><span class="p">(</span><span class="n">ISession</span> <span class="o">*</span><span class="n">ses</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVals</span><span class="p">,</span><span class="n">IAddress</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">);</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">getBufSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">getEnvelope</span><span class="p">(</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">lHeader</span><span class="p">,</span><span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">lTrailer</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">getSocketDefaults</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">protocol</span><span class="p">,</span><span class="kt">uint16_t</span><span class="o">&amp;</span> <span class="n">port</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">shutdown</span><span class="p">();</span>
	<span class="p">};</span>
	
	<span class="cm">/**</span>
<span class="cm">	 * Listener interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IListener</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">IService</span>	<span class="o">*</span><span class="n">getService</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">URIID</span>		<span class="n">getID</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">create</span><span class="p">(</span><span class="n">IServiceCtx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="kt">uint32_t</span><span class="o">&amp;</span> <span class="n">dscr</span><span class="p">,</span><span class="n">IService</span><span class="o">::</span><span class="n">Processor</span> <span class="o">*&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">stop</span><span class="p">(</span><span class="n">bool</span> <span class="n">fSuspend</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * Listener initialization notification</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IListenerNotification</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">RC</span>	<span class="n">onListener</span><span class="p">(</span><span class="n">ISession</span> <span class="o">*</span><span class="n">ses</span><span class="p">,</span><span class="n">URIID</span> <span class="n">sid</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nVals</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">srvInfo</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nSrvInfo</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">bool</span> <span class="n">fStop</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * external language interpreter interface</span>
<span class="cm">	 */</span>
	<span class="n">class</span> <span class="n">IStoreLang</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
	<span class="p">};</span>

	<span class="cm">/**</span>
<span class="cm">	 * current store state</span>
<span class="cm">	 * @see IAffinity::getState()</span>
<span class="cm">	 */</span>
<span class="cp">	#define	SSTATE_OPEN					0x0001											</span><span class="cm">/**&lt; store is loaded, no external access operations */</span><span class="cp"></span>
<span class="cp">	#define	SSTATE_READONLY				0x0002											</span><span class="cm">/**&lt; only read operations so far */</span><span class="cp"></span>
<span class="cp">	#define	SSTATE_NORESOURCES			0x0004											</span><span class="cm">/**&lt; critical NORESOURCE situation, e.g. no space for log files; only read access is allowed */</span><span class="cp"></span>
<span class="cp">	#define	SSTATE_IN_SHUTDOWN			0x0008											</span><span class="cm">/**&lt; store is being shutdown */</span><span class="cp"></span>
<span class="cp">	#define	SSTATE_MODIFIED				0x0010											</span><span class="cm">/**&lt; data was modified */</span><span class="cp"></span>

	<span class="n">class</span> <span class="n">IAfySocket</span><span class="p">;</span>

	<span class="n">class</span> <span class="n">AFY_EXP</span> <span class="n">IAffinity</span> <span class="o">:</span> <span class="n">public</span> <span class="n">IMemAlloc</span>
	<span class="p">{</span>
	<span class="nl">public:</span>
		<span class="k">virtual</span>	<span class="n">ISession</span>	<span class="o">*</span><span class="n">startSession</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">identityName</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">initMem</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>				<span class="cm">/**&lt; start new session, optional login, optional stack memory allocation */</span>
		<span class="k">virtual</span>	<span class="kt">unsigned</span>	<span class="n">getState</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																						<span class="cm">/**&lt; get current store state asynchronously */</span>
		<span class="k">virtual</span>	<span class="kt">size_t</span>		<span class="n">getPublicKey</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">lbuf</span><span class="p">,</span><span class="n">bool</span> <span class="n">fB64</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>													<span class="cm">/**&lt; get store public key */</span>
		<span class="k">virtual</span>	<span class="kt">uint64_t</span>	<span class="n">getOccupiedMemory</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																				<span class="cm">/**&lt; for inmem store: return currently used memory */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">changeTraceMode</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">mask</span><span class="p">,</span><span class="n">bool</span> <span class="n">fReset</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>														<span class="cm">/**&lt; change trace mode, see TRACE_XXX flags above  */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerLangExtension</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">langID</span><span class="p">,</span><span class="n">IStoreLang</span> <span class="o">*</span><span class="n">ext</span><span class="p">,</span><span class="n">URIID</span> <span class="o">*</span><span class="n">pID</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>								<span class="cm">/**&lt; register external langauge interpreter */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerService</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">,</span><span class="n">IService</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span><span class="n">URIID</span> <span class="o">*</span><span class="n">puid</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="n">IListenerNotification</span> <span class="o">*</span><span class="n">lnot</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; register a handler for external actions by name */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerService</span><span class="p">(</span><span class="n">URIID</span> <span class="n">serviceID</span><span class="p">,</span><span class="n">IService</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span><span class="n">IListenerNotification</span> <span class="o">*</span><span class="n">lnot</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>					<span class="cm">/**&lt; register a handler for external actions */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">unregisterService</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sname</span><span class="p">,</span><span class="n">IService</span> <span class="o">*</span><span class="n">handler</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>											<span class="cm">/**&lt; remove a handler for external actions, if handler==NULL - all handlers for this service */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">unregisterService</span><span class="p">(</span><span class="n">URIID</span> <span class="n">serviceID</span><span class="p">,</span><span class="n">IService</span> <span class="o">*</span><span class="n">handler</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>												<span class="cm">/**&lt; remove a handler for external actions, if handler==NULL - all handlers for this service */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerSocket</span><span class="p">(</span><span class="n">IAfySocket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																		<span class="cm">/**&lt; registering socket callback interface (see afysock.h for details */</span>
		<span class="k">virtual</span>	<span class="kt">void</span>		<span class="n">unregisterSocket</span><span class="p">(</span><span class="n">IAfySocket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span><span class="n">bool</span> <span class="n">fClose</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>															<span class="cm">/**&lt; unregistering socket callback interface (see afysock.h for details */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerPrefix</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">qs</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">lq</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">ls</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>										<span class="cm">/**&lt; for service libraries - to register their qname prefixes */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerFunction</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span><span class="n">RC</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">moreArgs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nargs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span><span class="n">ISession</span> <span class="o">*</span><span class="n">ses</span><span class="p">),</span><span class="n">URIID</span> <span class="n">serviceID</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/**&lt; register external function by name */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerFunction</span><span class="p">(</span><span class="n">URIID</span> <span class="n">funcID</span><span class="p">,</span><span class="n">RC</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">moreArgs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nargs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span><span class="n">ISession</span> <span class="o">*</span><span class="n">ses</span><span class="p">),</span><span class="n">URIID</span> <span class="n">serviceID</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/**&lt; register external function */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">registerOperator</span><span class="p">(</span><span class="n">ExprOp</span> <span class="n">op</span><span class="p">,</span><span class="n">RC</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">Value</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">,</span><span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">moreArgs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">nargs</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span><span class="n">ISession</span> <span class="o">*</span><span class="n">ses</span><span class="p">),</span>
											<span class="n">URIID</span> <span class="n">serviceID</span><span class="p">,</span><span class="kt">int</span> <span class="n">nargs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">ntypes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="k">const</span> <span class="n">ValueType</span> <span class="o">**</span><span class="n">argTypes</span><span class="o">=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/**&lt; register external operator */</span>
		<span class="k">virtual</span>	<span class="n">RC</span>			<span class="n">shutdown</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>																								<span class="cm">/**&lt; shutdowns store instance */</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cp">#ifdef _MSC_VER</span>
<span class="cp">#pragma warning(disable:4291)</span>
<span class="cp">#pragma warning(disable:4251)</span>
<span class="cp">#pragma warning(disable:4355)</span>
<span class="cp">#pragma	warning(disable:4181)</span>
<span class="cp">#pragma	warning(disable:4512)</span>
<span class="cp">#pragma	warning(disable:4100)</span>
<span class="cp">#else</span>
<span class="cp">#define __forceinline	inline</span>
<span class="cp">#endif</span>

<span class="n">__forceinline</span> <span class="kt">void</span><span class="o">*</span>	<span class="n">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">,</span><span class="n">Afy</span><span class="o">::</span><span class="n">IMemAlloc</span> <span class="o">*</span><span class="n">ma</span><span class="p">)</span> <span class="n">throw</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">ma</span><span class="o">-&gt;</span><span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);}</span>
<span class="n">__forceinline</span> <span class="kt">void</span><span class="o">*</span>	<span class="n">operator</span> <span class="n">new</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">,</span><span class="n">Afy</span><span class="o">::</span><span class="n">IMemAlloc</span> <span class="o">*</span><span class="n">ma</span><span class="p">)</span> <span class="n">throw</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">ma</span><span class="o">-&gt;</span><span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);}</span>

<span class="cp">#endif</span>
</pre></div>
<!-- end highlighted code -->

</div>
