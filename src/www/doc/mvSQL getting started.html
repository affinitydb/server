<head>
  <script src='js/jquery.js' type='text/javascript'></script>
  <script src='js/snippets_to_console.js' type='text/javascript'></script>
  <link href='css/mvdoc.css' rel='stylesheet' type='text/css' />
</head>
<div id='mvtocbar'>
  <select id='mvtoclist'>
    <option value='features'>features</option>
    <option value='intro'>intro</option>
    <option value='mvSQL getting started' SELECTED>mvSQL getting started</option>
    <option value='mvSQL reference'>mvSQL reference</option>
    <option value='mvStore FAQ'>mvStore FAQ</option>
    <option value='mvStore cpp'>mvStore cpp</option>
    <option value='mvStore getting started'>mvStore getting started</option>
    <option value='mvStore js'>mvStore js</option>
    <option value='mvStore protobuf'>mvStore protobuf</option>
    <option value='mvStore server'>mvStore server</option>
    <option value='release notes'>release notes</option>
    <option value='strengths'>strengths</option>
    <option value='terminology'>terminology</option>
  </select>
</div>
<div id="getting-started-with-mvsql"
><h1
  >Getting Started with mvSQL</h1
  ><p
  >mvSQL is the name of a dialect of SQL defined for mvStore. Although the <a href="./terminology.html#essential-concepts-data-model"
    >mvStore data model</a
    > is different from relational databases, mvSQL is designed to be as close to SQL as possible. This document shows <strong
    >how to</strong
    > insert, update, query and index data (<a href="./terminology.html#pin"
    >PINs</a
    >).</p
  ><p
  >For a more systematic survey of mvSQL and its commands, please visit the <a href="./mvSQL%20reference.html"
    >reference</a
    >.</p
  ><p
  >To setup a runtime environment, please visit this <a href="./mvStore%20getting%20started.html"
    >link</a
    >.</p
  ><div id="how-to-insert-data"
  ><h2
    >How to insert data</h2
    ><p
    >There is no concept of table in mvStore: all data are inserted in global scope. Two styles can be used to perform <a href="./terminology.html#pin"
      >PIN</a
      > inserts:</p
    ><ol style="list-style-type: decimal;"
    ><li
      >SQL-like syntax:</li
      ></ol
    ><p
    ><code class='mvsql_snippet'>INSERT (property1, property2) VALUES ('value1','value2');</code></p
    ><ol start="2" style="list-style-type: decimal;"
    ><li
      >mvStore-specific syntax:</li
      ></ol
    ><p
    ><code class='mvsql_snippet'>INSERT property1 ='value1', property2 ='value2';</code></p
    ><p
    >Different <a href="./mvSQL%20reference.html#data-types"
      >data types</a
      > may have different input formats, e.g.</p
    ><p
    ><code class='mvsql_snippet'>INSERT prop_string ='string', prop_binary_string =X'DEF5', prop_url=U'http://test/', prop_int=128, prop_float=3.40282f, prop_double=3.40282, prop_bool=true, prop_datatime=TIMESTAMP '2010-12-31 23:59:59', prop_internal=INTERVAL '-12:00:00', prop_collection={1,2,4};</code></p
    ><pre
    ><code
      >    PIN@00000000000D000D(10):(&lt;prop_string|VT_STRING&gt;:string  &lt;prop_binary_string|VT_BSTR&gt;:DEF5  &lt;prop_url|VT_URL&gt;:http://test/  &lt;prop_int|VT_INT&gt;:128  &lt;prop_float|VT_FLOAT&gt;:3.40282  &lt;prop_double|VT_DOUBLE&gt;:3.40282  &lt;prop_bool|VT_BOOL&gt;:TRUE  &lt;prop_datatime|VT_DATETIME&gt;:2010-12-31 23:59:59  &lt;prop_internal|VT_INTERVAL&gt;:-12:00:00  &lt;prop_collection|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_INT&gt;:2, &lt;2|VT_INT&gt;:4})
    1 PINs INSERTED.   
</code
      ></pre
    ><p
    >Other examples:</p
    ><p
    ><code class='mvsql_snippet'>INSERT name='Jurgen', bornin='South Africa', email='jleschner@vmware.com', livesin='Boston';</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;}
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>INSERT (name, bornin, email, livesin) VALUES ('Sonny', 'USA', 'sthai@mit.edu', 'Boston');</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: &quot;Boston&quot;}
</code
      ></pre
    ></div
  ><div id="how-to-update-or-delete-data"
  ><h2
    >How to update or delete data</h2
    ><p
    ><code class='mvsql_snippet'>UPDATE ADD livesin='Cambridge' WHERE name = 'Sonny';</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;Cambridge&quot;}}
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>UPDATE SET livesin[1]='USA' WHERE name='Sonny';</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}}
</code
      ></pre
    ><p
    ><code class='mvsql_inert'>UPDATE @A0001 ADD school='MIT';</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}, &quot;school&quot;: &quot;MIT&quot;}
</code
      ></pre
    ><p
    ><code class='mvsql_inert'>delete @A0001;</code></p
    ></div
  ><div id="how-to-classify-data"
  ><h2
    >How to classify data</h2
    ><p
    >All data are inserted in global scope, but applications can freely define specialized access paths for their data (before or after the data is inserted), by creating what we call <a href="./terminology.html#class"
      >classes</a
      >. Here's an example:</p
    ><p
    ><code class='mvsql_snippet'>CREATE CLASS class1 AS SELECT * WHERE property1 IS NOT NULL;</code></p
    ></div
  ><div id="how-to-query"
  ><h2
    >How to query</h2
    ><p
    >Most of the querying syntax in mvStore is compatible with standard SQL: expressions, function calls, WHERE, ORDER BY, UNION, INTERSECT, EXCEPT etc. Here's an example:</p
    ><p
    ><code class='mvsql_snippet'>SELECT * FROM class1 WHERE LENGTH(property2) &gt; 5 ORDER BY property2 DESC NULLS FIRST;</code></p
    ><p
    >Other examples:</p
    ><p
    ><code class='mvsql_snippet'>SELECT name WHERE EXISTS(livesin);</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;}
    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;}
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>SELECT WHERE livesin = 'Boston' ORDER BY name ASC;</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;}
    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}, &quot;school&quot;: &quot;MIT&quot;}
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>SELECT * MATCH AGAINST ('Boston');</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;}
    {&quot;id&quot;:&quot;00000000000A0001&quot;, &quot;name&quot;: &quot;Sonny&quot;, &quot;bornin&quot;: &quot;USA&quot;, &quot;email&quot;: &quot;sthai@mit.edu&quot;, &quot;livesin&quot;: {&quot;0&quot;: &quot;Boston&quot;,&quot;1&quot;: &quot;USA&quot;}, &quot;school&quot;: &quot;MIT&quot;}
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>SELECT * MATCH AGAINST ('South');</code></p
    ><pre
    ><code
      >    {&quot;id&quot;:&quot;00000000000A0000&quot;, &quot;name&quot;: &quot;Jurgen&quot;, &quot;bornin&quot;: &quot;South Africa&quot;, &quot;email&quot;: &quot;jleschner@vmware.com&quot;, &quot;livesin&quot;: &quot;Boston&quot;}
</code
      ></pre
    ></div
  ><div id="how-to-use-join"
  ><h2
    >How to use join</h2
    ><p
    >mvStore returns immutable PIN collections as query results. Presently, the join results are somewhat limited (they only contain PINs from the left-hand class). Here's an example:</p
    ><p
    ><code class='mvsql_snippet'>SELECT * FROM class1 AS c1 JOIN class2 AS c2 ON (c1.prop1 = c2.prop2);</code></p
    ><p
    >mvStore supports every kind of JOIN (LEFT/RIGHT/FULL/CROSS JOIN), except the Natural JOIN.</p
    ></div
  ><div id="how-to-use-references"
  ><h2
    >How to use <a href="./terminology.html#pin-reference"
      >references</a
      ></h2
    ><p
    >Relational databases use foreign keys to establish relationships between tables. mvStore uses <a href="./terminology.html#pin-reference"
      >references</a
      >, similarly to object-oriented databases:</p
    ><p
    ><code class='mvsql_snippet'>INSERT (prop1) VALUES ({'test for pin refer', 'test for property refer', 'test for property element refer'});</code></p
    ><pre
    ><code
      >    PIN@0000000000050001(1):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_STRING&gt;:test for pin refer,&lt;1|VT_STRING&gt;:test for property refer, &lt;2|VT_STRING&gt;:test for property element refer})
    1 PINs INSERTED.
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>INSERT (propRef, prop2) VALUES (@50001, 'test for ref pin');</code></p
    ><pre
    ><code
      >    PIN@0000000000050002(2):(&lt;propRef|VT_REFID&gt;:PIN@0000000000050001        &lt;prop2|VT_STRING&gt;:test for ref pin)
    1 PINs INSERTED.
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>INSERT (propRef, prop2) VALUES (@50001.prop1, 'test for ref property');</code></p
    ><pre
    ><code
      >    PIN@0000000000050003(2):(&lt;propRef|VT_REFIDPROP&gt;:PIN@0000000000050001.prop1&lt;prop2|VT_STRING&gt;:test for ref property)
    1 PINs INSERTED.
</code
      ></pre
    ><p
    ><code class='mvsql_snippet'>INSERT (propRef, prop2) VALUES (@50001.prop1[2], 'test for ref property element');</code></p
    ><pre
    ><code
      >    PIN@0000000000050004(2):(&lt;propRef|VT_REFIDELT&gt;:PIN@0000000000050001.prop1[2]&lt;prop2|VT_STRING&gt;:test for ref property element)
    1 PINs INSERTED.
</code
      ></pre
    ><p
    >To leverage this information while querying, mvStore offers the following syntax (path expression):</p
    ><p
    ><code class='mvsql_snippet'>SELECT * WHERE COUNT(propRef.prop1) &gt; 1;</code><br
       /> <code class='mvsql_snippet'>SELECT * FROM myclass WHERE propRef.prop2 IN (1, 2, 3);</code></p
    ><p style="color:red">REVIEW (maxw): add more stuff here.</p>
</div
  ><div id="how-to-use-collections"
  ><h2
    >How to use <a href="./terminology.html#collection"
      >collections</a
      ></h2
    ><div id="add-elements-to-a-collection"
    ><h3
      >1. Add elements to a <a href="./terminology.html#collection"
	>collection</a
	></h3
      ><div id="insert-a-pin-with-a-collection-property:"
      ><h4
	>1.1 Insert a PIN with a collection property:</h4
	><p
	><code class='mvsql_snippet'>INSERT (prop1, prop2) VALUES ({1, 'inserted', '3'}, 2);</code></p
	><pre
	><code
	  >    PIN@0000000000050001(2):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted, &lt;2|VT_STRING&gt;:3}    &lt;prop2|VT_INT&gt;:2)
    1 PINs INSERTED.
</code
	  ></pre
	></div
      ><div id="update-a-property-in-a-collection"
      ><h4
	>1.2 Update a property in a collection</h4
	><p
	>Using &quot;UPDATE ... SET ...&quot;, we can replace a property with a whole collection directly:</p
	><p
	><code class='mvsql_inert'>UPDATE @50001 SET prop3={3, 'update set'};</code></p
	><pre
	><code
	  >    PIN@0000000000050001(3):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted, &lt;2|VT_STRING&gt;:3}      &lt;prop2|VT_INT&gt;:2        &lt;prop3|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:3, &lt;1|VT_STRING&gt;:update set})   
    1 PINs UPDATED.  
</code
	  ></pre
	><p
	>Using &quot;UPDATE ... ADD ...&quot;, we can convert a property from a scalar value to a collection:</p
	><p
	><code class='mvsql_inert'>UPDATE @50001 ADD prop2='update add';</code></p
	><pre
	><code
	  >    PIN@0000000000050001(3):(&lt;prop1|VT_ARRAY(3)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted, &lt;2|VT_STRING&gt;:3}      &lt;prop2|VT_ARRAY(2)&gt;:{&lt;prop2|VT_INT&gt;:2, &lt;prop2|VT_STRING&gt;:updateadd}    &lt;prop3|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:3, &lt;1|VT_STRING&gt;:update set})  
    1 PINs UPDATED.  
</code
	  ></pre
	></div
      ></div
    ><div id="delete-an-element-from-a-collection"
    ><h3
      >2. Delete an element from a collection</h3
      ><p
      ><code class='mvsql_inert'>UPDATE @50001 DELETE prop1[2];</code></p
      ><pre
      ><code
	>    PIN@0000000000050001(3):(&lt;prop1|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:1, &lt;1|VT_STRING&gt;:inserted} &lt;prop2|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:2, &lt;1|VT_STRING&gt;:update add}    &lt;prop3|VT_ARRAY(2)&gt;:{&lt;0|VT_INT&gt;:3, &lt;1|VT_STRING&gt;:update set})  
    1 PINs UPDATED.  
</code
	></pre
      ></div
    ><div id="query-on-collections"
    ><h3
      >3. Query on collections</h3
      ><p
      >Here are a few examples of queries that can be run against the PIN created in section 1.1:</p
      ><blockquote
      ><ol style="list-style-type: decimal;"
	><li
	  >SELECT * WHERE 1 IN prop1;<br
	     /></li
	  ><li
	  >SELECT * WHERE {1,2} IN prop1;<br
	     /></li
	  ><li
	  >SELECT * WHERE CARDINALITY(prop1)=2;<br
	     /></li
	  ><li
	  >SELECT * WHERE 1 = prop1; -- equivalent to example 1.</li
	  ><li
	  >SELECT * WHERE {1,2} = prop1; -- equivalent to example 2.</li
	  ></ol
	></blockquote
      ></div
    ></div
  ><div id="how-to-index-properties"
  ><h2
    >How to index properties</h2
    ><p
    >mvStore does not support the &quot;CREATE INDEX&quot; statement. However, it proposes a somewhat similar statement: &quot;CREATE CLASS family&quot;. Here's an example:</p
    ><p
    ><code class='mvsql_snippet'>CREATE CLASS clsfml1 AS select * where prop1 = :0(int, desc, nulls first) and prop2=:1(int);</code></p
    ><p
    >This class <a href="./terminology.html#family"
      >family</a
      > will create an <a href="./terminology.html#index"
      >index</a
      > on prop1 and prop2. The prop1 will be sorted in descending order, and will order nulls first. When parameters are passed, the class family behaves like a CLASS. For example:</p
    ><p
    ><code class='mvsql_snippet'>SELECT * FROM clsfml5(*, 2);</code></p
    ><pre
    ><code
      >    PIN@0000000000050012(2):(&lt;prop2|VT_INT&gt;:2   &lt;prop3|VT_STRING&gt;:test NULL)   
    PIN@0000000000050013(3):(&lt;prop1|VT_DOUBLE&gt;:13.3 &lt;prop2|VT_INT&gt;:2    &lt;prop3|VT_STRING&gt;:extra)   
    PIN@0000000000050018(2):(&lt;prop1|VT_DOUBLE&gt;:12.1 &lt;prop2|VT_INT&gt;:2)   
    PIN@0000000000050019(3):(&lt;prop1|VT_INT&gt;:12  &lt;prop2|VT_INT&gt;:2    &lt;prop3|VT_DOUBLE&gt;:34)   
    4 PINs SELECTED.   
</code
      ></pre
    ></div
  ></div
>
