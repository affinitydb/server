<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' />
  <script src='js/jquery.js' type='text/javascript'></script>
  <script src='js/snippets_to_console.js' type='text/javascript'></script>
  <link href='css/afydoc.css' rel='stylesheet' type='text/css' media='screen and (min-device-width: 600px)' />
  <link href='../m/doc/css/afydoc.css' rel='stylesheet' type='text/css' media='screen and (max-device-width: 599px)' />
  <meta http-equiv='content-type' content='text/html; charset=utf-8'></meta>
</head>
<div id='width_constraint' class='horizontally_centered'>
<div id='generic_header'>
<img src='images/logo_small.png' id='gh_logo_img'></img>
<div id='afytocbar'>
  <select id='afytoclist'>
    <option value='intro'>intro</option>
    <option value='FAQ'>FAQ</option>
    <option value='features'>features</option>
    <option value='getting started'>getting started</option>
    <option value='interface [cplusplus]'>interface [cplusplus]</option>
    <option value='interface [javascript]'>interface [javascript]</option>
    <option value='interface [protobuf]'>interface [protobuf]</option>
    <option value='pathSQL basics [control]'>pathSQL basics [control]</option>
    <option value='pathSQL basics [data]'>pathSQL basics [data]</option>
    <option value='pathSQL reference [definition]'>pathSQL reference [definition]</option>
    <option value='pathSQL reference [manipulation]'>pathSQL reference [manipulation]</option>
    <option value='pathSQL reference'>pathSQL reference</option>
    <option value='release notes'>release notes</option>
    <option value='server'>server</option>
    <option value='strengths'>strengths</option>
    <option value='terminology' SELECTED>terminology</option>
    <option value='demo_EULA'>demo_EULA</option>
    <option value='demo_privacy'>demo_privacy</option>
  </select>
</div>
</div>
<div id="list-of-terms"
><h1
  >List of Terms</h1
  ><p
  ><a href="#acl"
    >ACL</a
    >, <a href="#action"
    >action</a
    >, <a href="#blob"
    >BLOB</a
    >, <a href="#c-kernel-interface"
    >C++ interface</a
    >, <a href="#cep"
    >CEP</a
    >, <a href="#class"
    >class</a
    >, <a href="#client-side-libraries"
    >client-side library</a
    >, <a href="#coercion"
    >coercion</a
    >, <a href="#collection"
    >collection</a
    >, <a href="#communication-pin"
    >communication PIN</a
    >, <a href="#condition"
    >condition</a
    >, <a href="#essentials-data-model"
    >data model</a
    >, <a href="#element-id-eid"
    >element ID (eid)</a
    >, <a href="#encryption"
    >encryption</a
    >, <a href="#enumeration"
    >enumeration</a
    >, <a href="#family"
    >family</a
    >, <a href="#fsm"
    >FSM</a
    >, <a href="#identity"
    >identity</a
    >, <a href="#index"
    >index</a
    >, <a href="#kernel"
    >kernel</a
    >, <a href="#loader"
    >loader</a
    >, <a href="#map"
    >map</a
    >, <a href="#namespace"
    >namespace</a
    >, <a href="#notification"
    >notification</a
    >, <a href="#page"
    >page</a
    >, <a href="#parameter"
    >parameter</a
    >, <a href="#pathsql"
    >pathSQL</a
    >, <a href="#pin"
    >PIN</a
    >, <a href="#pin-id-pid"
    >PIN ID (PID)</a
    >, <a href="#property"
    >property</a
    >, <a href="#protocol-buffer"
    >protocol-buffer</a
    >, <a href="#rdf"
    >RDF</a
    >, <a href="#pin-reference"
    >reference</a
    >, <a href="#replication"
    >replication</a
    >, <a href="#rule"
    >rule</a
    >, <a href="#server"
    >server</a
    >, <a href="#service"
    >service</a
    >, <a href="#ssv"
    >SSV</a
    >, <a href="#structure"
    >structure</a
    >, <a href="#timer"
    >timer</a
    >, <a href="#uncommitted-pin"
    >uncommitted PIN</a
    >, <a href="#unit-of-measurement"
    >unit of measurement</a
    >, <a href="#value"
    >value</a
    ></p
  ><!-- [snapshot isolation](#snapshot-isolation) -->
</div
><div id="essentials-data-model"
><h1
  >Essentials (Data Model)</h1
  ><p
  >The key components of Affinity's data model can be presented on two layers:</p
  ><ol style="list-style-type: decimal;"
  ><li
    >a base layer (plain &quot;passive&quot; data items): <a href="#pin"
      >PIN</a
      >, <a href="#property"
      >property</a
      >, <a href="#value"
      >value</a
      > (including <a href="#pin-reference"
      >references</a
      >), <a href="#collection"
      >collection</a
      >, <a href="#class"
      >class</a
      ><br
       /></li
    ><li
    >an active layer, <span class='pathsql_new'>NEW in AffinityNG</span> (components of this layer are built upon the base layer): <a href="#condition"
      >condition</a
      >, <a href="#action"
      >action</a
      >, <a href="#rule"
      >rule</a
      >, <a href="#fsm"
      >FSM</a
      >, <a href="#cep"
      >CEP</a
      >, <a href="#timer"
      >timer</a
      >, <a href="#service"
      >service</a
      >, <a href="#communication-pin"
      >communication PIN</a
      ></li
    ></ol
  ><div id="data-model:-basic-components"
  ><h2
    >Data Model: Basic Components</h2
    ><div id="pin"
    ><h3
      >PIN</h3
      ><p
      >The PIN is Affinity's primary information node. It's the basic unit of data. It is somewhat analogous to the object of an object-oriented programming language or database, the row of a relational table, the node of a graph database or of XML's DOM, the document of a document database etc. A PIN can live in memory only, and can also be persistent - transitions between these two states is practically seemless, since the PIN's content access interface is the same in both cases. A PIN can contain many <a href="#property"
	>properties</a
	>. Each property of a PIN holds a <a href="#value"
	>value</a
	>, which can be a simple scalar, a collection, a map or a complex tree structure. Unlike rdbms rows, PINs aren't constrained to any table, and can actually belong to many <a href="#class"
	>classes</a
	>. Each PIN can describe its own unique structure (i.e. enumerate its <a href="#property"
	>properties</a
	>). PINs can <a href="#pin-reference"
	>refer</a
	> to each other. Properties can be added to PINs (or removed) without limitation. Each PIN is uniquely identified by a <a href="#pin-id-pid"
	>PIN ID</a
	>. Also <span class='pathsql_new'>NEW in AffinityNG</span>, a PIN can be <a href="./pathSQL%20basics%20[data].html#named-pins"
	>named</a
	>.</p
      ><p
      ><em
	>Note: the theoretical maximum number of properties per PIN is related with the configured <a href="#page"
	  >page</a
	  > size - typically, in the order of thousands of properties on a PIN; this limit only puts a boundary on the structural complexity of a PIN, not the amount of data that each property can contain</em
	></p
      ></div
    ><div id="property"
    ><h3
      >Property</h3
      ><p
      >Properties are symbolic entities (names) that define the relationship between a <a href="#pin"
	>PIN</a
	> and its <a href="#value"
	>values</a
	>. Properties define the structure of a PIN. A property, in Affinity, is somewhat analogous to the column name of a relational table, to a predicate in <a href="#rdf"
	>RDF</a
	>, to the field of a structure in C, or to the property of an object in a standard object-oriented programming language. Property names can be composed of multiple sections, separated by a slash (/) character, following the same convention as URIs. This enables a practically infinite, semantically coherent <a href="#namespace"
	>namespace</a
	> usable across multiple applications (which may not necessarily be fully aware of each other). The basic data model of Affinity does not attach any type information to properties: instances of a property (<a href="#value"
	>values</a
	>) can be of any type. Properties are a key component of <a href="#class"
	>class</a
	> definitions, because they establish a semantic relationship across PINs (two PINs that contain the same property have something in common, and can be classified accordingly). Because there is no constraint on any value's type, Affinity may perform data type <a href="#coercion"
	>coercion</a
	> when required. Internally, a numeric ID is associated with each property. This ID is only valid in the scope of one database instance; any reference to a property outside of that scope must use the textual representation of the property.</p
      ><p
      >In the data modeling process with Affinity, selecting meaninful, stable property names constitutes an important first step, that can influence the effectiveness of categorization into <a href="#class"
	>classes</a
	> later on. When possible, it is recommended to refer to an already existing source (ontology). The semantic web community uses resources such as the following, to achieve similar goals:</p
      ><ul
      ><li
	><a href="http://sindice.com"
	  >http://sindice.com</a
	  ></li
	><li
	><a href="http://www.sameas.org"
	  >http://www.sameas.org</a
	  ></li
	><li
	><a href="http://www.daml.org/ontologies/"
	  >DAML</a
	  ></li
	></ul
      ></div
    ><div id="value"
    ><h3
      >Value</h3
      ><p
      >Like in any database, values can be numbers, strings, booleans, dates, times, <a href="#blob"
	>BLOBs</a
	> etc. A value can also be a <a href="#pin-reference"
	>reference</a
	> to another <a href="#pin"
	>PIN</a
	> (or to another <a href="#property"
	>property</a
	> of a PIN, or even to a specific collection <a href="#element-id-eid"
	>element</a
	>). At the programming level, the same value structure is also used to hold a <a href="#collection"
	>collection</a
	>, a <a href="#structure"
	>structure</a
	> or a <a href="#map"
	>map</a
	>. As a result, the full addressing model of a standard programming language is readily available in <a href="#pathsql"
	>pathSQL</a
	>. Additionally, Affinity provides a data type attribute allowing to attach a physical <a href="#unit-of-measurement"
	>unit of measurement</a
	> to a value. Data types are described in detail <a href="./pathSQL%20reference.html#data-types"
	>here</a
	>. In Affinity, every instance of a value is free to be of any type; in some contexts Affinity may perform automatic data type <a href="#coercion"
	>coercion</a
	>.</p
      ></div
    ><div id="collection"
    ><h3
      >Collection</h3
      ><p
      >A collection is an ordered list of scalar <a href="#value"
	>values</a
	>, held by a <a href="#pin"
	>PIN</a
	> via a <a href="#property"
	>property</a
	>. The values of a collection can be heterogeneous (they can have different types). Internally, each element of a collection is uniquely identified by an immutable <a href="#element-id-eid"
	>Element ID (eid)</a
	>. This design enables consistent interactions in concurrent access scenarios. Note that collections cannot directly contain nested collections, in the current version. Small collections can be represented as arrays internally, and allow random access, whereas very large collections must be traversed with an iterator (with the option of seeking to any known <a href="#element-id-eid"
	>eid</a
	>). A collection can hold up to 32-bit worth of distinct addressable elements. Collections can be queried just like plain values (additional control is provided). Collections also play a key role in other aspects of the data model, such as <a href="#acl"
	>ACLs</a
	>. Collections are represented by VT_COLLECTION in <a href="./sources/affinity_h.html"
	>affinity.h</a
	>.</p
      ></div
    ><div id="structure"
    ><h3
      >Structure</h3
      ><p
      >A structure is a set of labeled <a href="#value"
	>values</a
	>, aka a set of <a href="#property"
	>properties</a
	>. The structure is analogous to an embedded PIN (held &quot;by value&quot; by its owner PIN). Structures may contain substructures. Structures are represented by VT_STRUCT in <a href="./sources/affinity_h.html"
	>affinity.h</a
	>. They are a <span class='pathsql_new'>NEW</span> feature of AffinityNG (even though they were already a stealth feature in AffinityDB).</p
      ><!-- TODO: point to exact section in doc (make sure there is one; make sure to cover insert, update, query, delete) -->
</div
    ><div id="map"
    ><h3
      >Map</h3
      ><p
      >A map is an associative array (or dictionary) where both the value and the key itself are <a href="#value"
	>values</a
	>. Unlike the <a href="#property"
	>property</a
	> of a <a href="#pin"
	>PIN</a
	>, the key of a map is not limited to a symbolic entity: it can be anything. The map essentially opens up full access to Affinity's internal B-link tree. Maps are represented by VT_MAP in <a href="./sources/affinity_h.html"
	>affinity.h</a
	>. They are a <span class='pathsql_new'>NEW</span> feature of AffinityNG.</p
      ><!-- TODO: point to exact section in doc (make sure there is one; make sure to cover insert, update, query, delete) -->
</div
    ><div id="class"
    ><h3
      >Class</h3
      ><p
      >The class is Affinity's main mechanism of data organization. It is very similar to the materialized view of some relational databases, in the sense that classification operates automatically (<a href="#pin"
	>PINs</a
	> are not explicitly declared to belong to a class) and synchronously (in the context of transactions). Where a table or a view would be used in the relational model, one could use a class in Affinity to achieve a similar organization. A class is a stored query predicate (involving any number of <a href="#property"
	>properties</a
	>). It is most often defining an <a href="#index"
	>index</a
	>, although this is not mandatory. Classes can be declared at any point in time (both earlier and later than the occurrence of PINs satisfying the predicate). In pathSQL, classes are declared with <a href="./pathSQL%20reference%20[definition].html#create-class"
	>CREATE CLASS</a
	>. Classes are named according to similar conventions as properties (using URIs). Unlike the 'classes' of programming languages such as C++ or java, Affinity classes don't define static <em
	>types</em
	>, in the sense that they don't establish a binding contract with <a href="#pin"
	>PINs</a
	>: a PIN can belong to a class during a part of its lifetime, and stop belonging to it during another period; as long as the PIN satisfies the predicate, it's part of the class. A PIN can belong to several classes at once. Classification triggers <a href="#notification"
	>notifications</a
	>. Affinity defines a generalization of classes called <a href="#family"
	>families</a
	>, but the term 'class' is often used to represent both concepts. 'Category' may also be used as a synonym for 'class' (to avoid the static type connotation).</p
      ></div
    ></div
  ><div id="data-model:-active-components"
  ><h2
    >Data Model: Active Components</h2
    ><p
    >Most of the material from this section is <span class='pathsql_new'>NEW</span> in AffinityNG.</p
    ><div id="condition"
    ><h3
      >Condition</h3
      ><p
      >A condition is a predicate, i.e. an expression evaluating to true or false: &quot;should condition X be met, do Y&quot;. Conditions are of common usage in programming languages in general, and in SQL. Those that are of particular interest in the context of the active layer of pathSQL are:</p
      ><ol style="list-style-type: decimal;"
      ><li
	>the predicates of <a href="#class"
	  >classes</a
	  >,</li
	><li
	>the conditions that define <a href="#rule"
	  >rules</a
	  >, and</li
	><li
	>the conditions that define state transitions in <a href="#fsm"
	  >FSMs</a
	  >, and constitute building blocks for the regular expressions used in <a href="#cep"
	  >CEP</a
	  ></li
	></ol
      ><p
      >In pathSQL most conditions are expressed in a declarative or functional style (as opposed to imperative), for example by callback: the statements defined in the <code
	>afy:onEnter</code
	> property of a class are invoked automatically by Affinity when the class's <code
	>afy:predicate</code
	> evaluates to true for a given PIN.</p
      ></div
    ><div id="action"
    ><h3
      >Action</h3
      ><p
      >An action is a list of <a href="./pathSQL%20reference.html#dml"
	>DML</a
	> statements, invoked upon the satisfaction of a <a href="#condition"
	>condition</a
	>. Examples of actions are the <code
	>afy:onEnter</code
	> property of a <a href="#class"
	>class</a
	>, or the <code
	>afy:action</code
	> property of a <a href="#timer"
	>timer</a
	>. Actions usually modify some state, either locally in the database, or externally via <a href="#communication-pin"
	>communication PINs</a
	>. Actions can cause new <a href="#condition"
	>conditions</a
	> to evaluate to true, and thus trigger a chain of actions.</p
      ><!-- TODO: Event -->
</div
    ><div id="rule"
    ><h3
      >Rule</h3
      ><p
      >A rule is a simple construct that binds a conjunction of <a href="#condition"
	>conditions</a
	> to a list of <a href="#action"
	>actions</a
	>. Internally, a rule functions very much like a <a href="#class"
	>non-indexed class (aka simple event handler)</a
	>. The rule hides implementation details, by presenting to the reader its conditions and actions as named entities, rather than code. Rules also allow to reuse and share conditions and actions. For more information, see the <a href="./pathSQL%20basics%20[control].html#rules"
	>basic example</a
	> and the <a href="./pathSQL%20reference%20[definition].html#rule"
	>reference section</a
	>.</p
      ></div
    ><div id="fsm"
    ><h3
      >FSM</h3
      ><p
      >A Finite State Machine (FSM) is a very common computational model represented as a graph, where vertices are states and edges are transitions. Any instance of a FSM operates on a specific set of PINs, that define its context. The transitions are a special type of <a href="#rule"
	>rules</a
	>, i.e. pairs of <a href="#condition"
	>conditions</a
	> and <a href="#action"
	>actions</a
	>, that operate in that local context. This provides a means of encapsulation, as well as a basis for the definition and recognition of <a href="#cep"
	>complex events</a
	>. Affinity's graph database engine makes it trivial to represent FSMs internally (and in pathSQL).</p
      ></div
    ><div id="cep"
    ><h3
      >CEP</h3
      ><p
      >Complex Event Processing (CEP) is the ability to express and detect more complex correlations of events (i.e. <a href="#condition"
	>conditions</a
	> encountered at discrete points in time). In pathSQL, those correlations are described as a regular expression of a <a href="#fsm"
	>FSM's</a
	> transitions. CEP is not readily available in the alpha release of AffinityNG.</p
      ><!-- TODO: review when available -->
</div
    ><div id="timer"
    ><h3
      >Timer</h3
      ><p
      >Timers invoke <a href="#action"
	>actions</a
	> at regular time intervals, in their own thread. The <a href="./pathSQL%20reference%20[definition].html#create-timer"
	>reference</a
	> describes in detail how to declare timers.</p
      ></div
    ><div id="communication-pin"
    ><h3
      >Communication PIN</h3
      ><p
      >Communication PINs are special PINs with dual personality. Their &quot;RAW&quot; form (i.e. their plain and simple set of <a href="#property"
	>properties</a
	> and <a href="#value"
	>values</a
	>), defines the configuration of the communication, including a stack of <a href="#service"
	>services</a
	>. In pathSQL, once a communication PIN is inserted, its configuration can be examined or modified by adding the <code
	>RAW</code
	> keyword to <code
	>SELECT</code
	> or <code
	>UPDATE</code
	>. The second personality, seen via non-decorated <code
	>SELECT</code
	> or <code
	>UPDATE</code
	>, is the active communication channel itself. In that context, <code
	>SELECT</code
	> acts as a read, and <code
	>UPDATE</code
	> acts as a write. The <a href="./pathSQL%20reference%20[definition].html#communication-pins"
	>reference</a
	> describes communication PINs in more detail.</p
      ></div
    ></div
  ></div
><div id="related-concepts"
><h1
  >Related Concepts</h1
  ><div id="pin-id-pid"
  ><h3
    >PIN ID (PID)</h3
    ><p
    >The <a href="#pin"
      >PIN</a
      > ID is a globally unique ID, <em
      >determined by Affinity</em
      > when a new PIN is first committed to the database. It's composed of two main sections: an <a href="#identity"
      >identity</a
      > ID, and a 64-bit value, unique in the scope of that identity. Within the scope of one instance of an Affinity database, PINs created by the owner can be designated with the second (64-bit) section only, since the first section will be 0 (STORE_OWNER) - this elision is common, for example in pathSQL's <a href="./pathSQL%20reference.html#refid"
      >references</a
      >. By convention, the text representation of this second section should always be in hex. PIDs are immutable, and are usually not recycled (if a PIN is deleted, there is no risk that dangling references would ever point to a new, unrelated PIN) - unless explicitly requested (e.g. to store streaming or temporary data). PIDs can be used to specify fixed sets of PINs in a query, or to hold on to a PIN, or to create <a href="#pin-reference"
      >references</a
      >.</p
    ></div
  ><div id="element-id-eid"
  ><h3
    >Element ID (eid)</h3
    ><p
    >In a <a href="#collection"
      >collection</a
      >, every value is associated with a unique, immutable Element ID (a 32-bit unsigned value, <em
      >determined by Affinity</em
      >). This eid is independent from the position of the element in the collection. A few special logical eids are defined in the Affinity <a href="#interfaces"
      >interfaces</a
      >, to let the client define an initial ordering for new collection elements: STORE_COLLECTION_ID, STORE_FIRST_ELEMENT, STORE_LAST_ELEMENT. As soon as the new elements are inserted in the database, Affinity gives them a new immutable eid.</p
    ></div
  ><div id="family"
  ><h3
    >Family</h3
    ><p
    >A family (short for &quot;family of <a href="#class"
      >classes</a
      >&quot;) is a generalization of the concept of class. It is sometimes referred to as a &quot;parametrized class&quot;. It can also be viewed as a sorted index, by analogy with the relational model. Whereas a simple class only indexes <a href="#pin-id-pid"
      >references to the PINs</a
      > that satisfy its predicate, a family also indexes the values of those PINs that correspond with free <a href="#parameter"
      >parameters</a
      > in the predicate. For example, one could define an &quot;adult&quot; <em
      >class</em
      > (with the predicate &quot;age &gt;= 18&quot;), or an &quot;age_limit&quot; <em
      >family</em
      > (with the predicate &quot;age &gt;= :0&quot;).</p
    ></div
  ><div id="enumeration"
  ><h3
    >Enumeration</h3
    ><p
    >An enumeration allows to declare inter-related symbolic values, without polluting the global namespace. This can be useful for managing states, options and conditions based on those. For a more detailed description, please visit the <a href="./pathSQL%20reference.html#create-enumeration"
      >reference</a
      >.</p
    ></div
  ><div id="parameter"
  ><h3
    >Parameter</h3
    >In the context of a class <a href="#family"
    >family</a
    >, a parameter is an unspecified (free) value in the definition of the predicate. It usually implies an <a href="#index"
    >index</a
    >. Typically, this <a href="#value"
    >value</a
    > is provided at query time. For example, using pathSQL, one could define:<pre>'CREATE CLASS age_limit AS select * where age >= :0;'</pre>and then query with<pre>'SELECT * FROM age_limit(18);'</pre>
</div
  ><div id="uncommitted-pin"
  ><h3
    >Uncommitted PIN</h3
    ><p
    >This terminology is deprecated. An uncommitted PIN designates a PIN that is not persisted. In AffinityNG, a large proportion of PINs may never be persisted (e.g. some may represent sample values of which only an aggregated value will be persisted, others may represent messages only meant to propagate events between sub-systems). AffinityNG distinguishes the concept of PINs living in memory only, from the loosely related concept of inserting PINs by batches (see <a href="./interface%20[cplusplus].html#ibatch"
      ><code
	>IBatch</code
	></a
      >).</p
    ></div
  ><div id="pin-reference"
  ><h3
    >PIN Reference</h3
    ><p
    >A reference is a special <a href="#value"
      >value</a
      > type that allows to create explicit relationships between <a href="#pin"
      >PINs</a
      >. It maps naturally to the concept of reference or pointer, in most programming languages. From a database perspective, it enables a form of navigation that can reduce significantly the number of joins required by an application. A <a href="#property"
      >property</a
      > can contain a <a href="#collection"
      >collection</a
      > of references. All types of references contain at least a <a href="#pin-id-pid"
      >PID</a
      >, but can also contain a <a href="#property"
      >property</a
      > ID, and even a specific <a href="#element-id-eid"
      >element ID</a
      >.</p
    ></div
  ><div id="blob"
  ><h3
    >BLOB</h3
    ><p
    >BLOBs (also known as streams) are binary large objects, such as documents, pictures, video streams etc. Affinity provides a special <a href="#value"
      >value</a
      > type to store them, along with interfaces to stream the data in and out.</p
    ></div
  ><div id="ssv"
  ><h3
    >SSV</h3
    ><p
    >SSV stands for &quot;separately stored value&quot;. This is one of the mechanisms that Affinity provides to control the physical arrangement of <a href="#pin"
      >PINs</a
      > and their <a href="#value"
      >values</a
      > on <a href="#page"
      >pages</a
      >. For example, a certain <a href="#class"
      >class</a
      > of PINs could represent information about files on disk. One property could be a thumbnail representation of the file. To improve data-locality of query-able properties of those PINs, the application could request that the <a href="#value"
      >values</a
      > of the thumbnail <a href="#property"
      >property</a
      > be stored on <em
      >separate</em
      > pages.</p
    ></div
  ><div id="identity"
  ><h3
    >Identity</h3
    ><p
    >Each instance of an Affinity database is associated with the <em
      >identity</em
      > of a primary owner. The owner can authorize guest users (<em
      >identities</em
      >) to access subsets of the data (using <a href="#acl"
      >ACLs</a
      >), or to create new data (in principle, the owner can also fetch data from another user's database and cache it locally, but this is not fully exposed in the current version). Each user is identified by name, and the store associates a numeric ID to each name (the numeric ID of the database owner is 0 (STORE_OWNER)). Within the context of any specific store instance, a fully qualified <a href="#pin-id-pid"
      >PID</a
      > contains the numeric ID of that <a href="#pin"
      >PIN</a
      >'s owner. Outside of that context (e.g. in serialized messages), the identity must be specified in textual form (there is no guaranty that two database instances will associate the same numeric ID to the same identities).</p
    ></div
  ><div id="encryption"
  ><h3
    >Encryption</h3
    ><p
    >The files of a database instance created with a specific <a href="#identity"
      >identity</a
      > and password can be encrypted (using AES encryption, on a per-<a href="#page"
      >page</a
      > basis). It is only possible to decrypt them with those identity and password. Affinity provides no mechanism to restore the owner's password, should it be forgotten.</p
    ></div
  ><div id="namespace"
  ><h3
    >Namespace</h3
    ><p
    >All <a href="#property"
      >properties</a
      > defined in Affinity belong to a unique, global namespace. To augment the semantic value of property names, and reduce the risk of undesired collisions, property names can be composed of as many particles as required (separated by the slash (/) character). Some of the Affinity programming interfaces also allow to perform operations in the context of a current subset of the global namespace (by analogy with URIs and xml, subsets are themselves designated as &quot;namespaces&quot;). This relieves the application developer from specifying full names everywhere.</p
    ></div
  ><div id="acl"
  ><h3
    >ACL</h3
    ><p
    >ACL stands for &quot;Access Control List&quot;. Affinity's data model allows to specify access rights on a per-<a href="#pin"
      >PIN</a
      > basis, for individual <a href="#identity"
      >identities</a
      >. However, in the initial release of the Affinity package, multi-user scenarios are not fully enabled yet.</p
    ></div
  ><div id="unit-of-measurement"
  ><h3
    >Unit of Measurement</h3
    ><p
    >Affinity provides a special <a href="#value"
      >value</a
      > attribute that allows to attach a physical unit to real number values (most of the common units for length, speed, surface, volume, weight etc. are supported, both in the metric and imperial systems). This enhances the semantic and self-descriptive capabilities of a PIN. It also enables Affinity to perform automatic conversions, when processing compatible types in expressions. Units are described in detail in the <a href="./pathSQL%20reference.html#units-of-measurement"
      >pathSQL reference</a
      >.</p
    ></div
  ><div id="rdf"
  ><h3
    >RDF</h3
    ><p
    >Affinity does not yet provide a complete solution for RDF, OWL or SPARQL. However, the core &quot;subject-predicate-object&quot; model can be easily represented with <a href="#pin"
      >PIN</a
      > as subject, <a href="#property"
      >property</a
      > as predicate, and <a href="#value"
      >value</a
      > as object.</p
    ></div
  ><div id="page"
  ><h3
    >Page</h3
    ><p
    >The page is the logical unit most closely related with the physical layout of data on disk. Every page represents a contiguous segment of the database file. When an instance of a Affinity database is created, an immutable page size must be specified (the default is 32768 bytes). Every element of information (<a href="#pin"
      >PINs</a
      >, <a href="#index"
      >indexes</a
      > etc.) is stored on one or more pages. Because disk io is typically very time consuming, and databases typically require more disk storage than memory can hold, an important task of database systems is to minimize io (by compacting as much data as possible on a page, by mapping pages in and out of memory as efficiently and infrequently as possible, by keeping related data on pages that are near, by organizing indexes to satisfy common queries with as few pages as possible, etc.). Although Affinity takes care of most of the complexity, the application developer must be at least minimally aware of these considerations (e.g. to optimize queries, and use features like <a href="#ssv"
      >SSVs</a
      > when appropriate).</p
    ></div
  ><div id="index"
  ><h3
    >Index</h3
    ><p
    >Affinity can automatically index any text <a href="#value"
      >value</a
      > of any <a href="#pin"
      >PIN</a
      >, to enable full text search. <a href="#class"
      >Classes</a
      > and <a href="#family"
      >families</a
      > also define indexes. All those indexes can be combined in queries for fast information retrieval and update. Affinity query processing does not infer index usage from generic query conditions: indexes must be explicitly designated in the queries. Indexes can contain heterogeneous values (values of different types). The type of an index can also be specified explicitly. Indexing may imply data type <a href="#coercion"
      >coercion</a
      >; if coercion fails for a value, the corresponding PIN won't be indexed for this family.</p
    ></div
  ><div id="coercion"
  ><h3
    >Coercion</h3
    ><p
    ><a href="#value"
      >Values</a
      > of a <a href="#pin"
      >PIN</a
      > can have any type. However, there are several circumstances where Affinity will need to evaluate or compare a <a href="#property"
      >property</a
      >, and expect a specific type <em
      >(for example, when evaluating a <a href="#family"
	>family</a
	>'s predicate for a PIN containing properties that match the predicate but with values that do not match the corresponding <a href="#parameter"
	>parameters</a
	> or <a href="#index"
	>index</a
	>)</em
      >. In such cases, Affinity can resort to coercion to translate values to the required type (e.g. strings to integers and vice versa).</p
    ></div
  ><div id="notification"
  ><h3
    >Notification</h3
    ><p
    >Notifications are similar to triggers, and allow to track changes on specific <a href="#pin"
      >PINs</a
      > or <a href="#class"
      >classes</a
      >. The notification functionality is exposed in a low-level way in the kernel (<a href="./sources/startup_h.html"
      >startup.h</a
      >), and is also available via the <a href="http://en.wikipedia.org/wiki/Comet_%28programming%29"
      >comet</a
      > pattern in the <a href="#server"
      >server</a
      >. In the future a highly scalable (asynchronous) messaging infrastructure will be added. By comparison with triggers and stored procedures, Affinity's notifications establish a more strict boundary between the kernel and application code. They enhance application code consistency and maintainability, by concentrating all the logic in one place, using one language. They can also constitute the starting point of a messaging system between database instances.</p
    ></div
  ><div id="replication"
  ><h3
    >Replication</h3
    ><p
    >Although several elements of Affinity's design take database replication into consideration, replication is not a part of the AffinityNG release. Database replication is typically used to increase reliability and accessibility.</p
    ><!--
###Snapshot Isolation
Affinity uses the Read-Only multiversion [ROMV] protocol for read-only transactions,
thus enabling non-blocking reads. This only applies to transactions that are explicitly
specified as read-only by the caller. These transactions read a snapshot that
will correspond to the effect of committed write transactions up to the point
the read-only transaction started (n.b. if the number of snapshots grows very large
at any point in time, an older [already allocated] snapshot may be used).
In contrast, plain read-write or read-only transactions (not explicitly marked as
read-only by the caller) progress according to the 2-phase-locking protocol,
and may in some cases read data items in a "newer" state than the corresponding explicit
read-only transaction would.
-->
</div
  ><div id="loader"
  ><h3
    >Loader</h3
    ><p
    >A loader is a declaration for an external <a href="#service"
      >service</a
      > dependency, in the form of a persistent <a href="#pin"
      >PIN</a
      >, containing essentially 2 properties: a user-defined URI to name the loader (this URI is stored in <code
      >afy:objectID</code
      >), and a relative or absolute path to the loadable library (stored in <code
      >afy:load</code
      >). Note that the loader's name is rarely used. The name by which a service is referred to insert it into a <a href="#communication-pin"
      >communication PIN's</a
      > service stack is defined statically (programmatically), by the service itself (e.g. the XML service is referred to by .srv:XML, aka &quot;http://affinityng.org/service/XML&quot;). Once stored, a loader PIN tells the kernel to reload the library whenever it starts up. The pathSQL statement is <a href="./pathSQL%20reference%20[definition].html#create-loader"
      >CREATE LOADER</a
      >.</p
    ></div
  ></div
><div id="interfaces"
><h1
  >Interfaces</h1
  ><p
  >The <a href="#kernel"
    >Affinity kernel library</a
    > is written in C++, and provides a <a href="#c-kernel-interface"
    >C++ interface</a
    > directly talking to the kernel. The main interface to Affinity is <a href="#pathsql"
    >pathSQL</a
    >, in which it is possible to write complete programs, with the benefit of having no data translations between multiple representations (in memory, persistent, or for specialized procedural interfaces). Additionally, a <a href="#protocol-buffer"
    >protocol-buffer</a
    >-based streaming interface is provided, for efficient data transfers in machine-to-machine scenarios, or for the more traditional client-server case (either via the <a href="#server"
    >server</a
    > or via communication <a href="#service"
    >services</a
    >). <a href="#client-side-libraries"
    >Client-side libraries</a
    > are also available.</p
  ><div id="c-kernel-interface"
  ><h3
    >C++ Kernel Interface</h3
    ><p
    ><a href="./sources/affinity_h.html"
      >affinity.h</a
      > (along with a few extensions in <a href="./sources/rc_h.html"
      >rc.h</a
      >, <a href="./sources/startup_h.html"
      >startup.h</a
      > and <a href="./sources/units_h.html"
      >units.h</a
      >) defines a self-contained, low-level interface directly connected to the Affinity kernel. It exposes a set of C++ abstract base classes (aka C++ interfaces), for which implementations are provided by the kernel, plus a few constants and structures. The IAffinity interface represents a store instance, and allows to create interactive sessions. The ISession interface represents a logical connection to a store instance, and provides an entry point for every possible interaction. It understands the <a href="#pathsql"
      >pathSQL</a
      > dialect, as well as the <a href="#protocol-buffer"
      >protocol-buffer</a
      > streaming interface. At a lower level, query conditions and <a href="#class"
      >class</a
      > predicates can be defined using expression trees (IExprTree), which enable the embedding application to develop any desired query language (e.g. sql, xquery, sparql, linq etc.), and compile it into this low-level representation. <a href="#pin"
      >PINs</a
      > are mainly represented by the IPIN interface, which allows fine-grained control of the in-memory snapshot of a PIN and related read-write activity to the store (in the context of one specific session). Since affinity.h is primarily a kernel integration interface (rather than the client interface in a client-server model), most of the design decisions related with memory and reference management were taken by ranking performance implications with higher importance than ease of use. Here's a <a href="./interface%20[cplusplus].html"
      >link</a
      > to more information.</p
    ></div
  ><div id="pathsql"
  ><h3
    >pathSQL</h3
    ><p
    >pathSQL is the name of a dialect of SQL defined for Affinity. pathSQL provides complete, self-contained access to all passive and active aspects of AffinityNG. Here's a <a href="./pathSQL%20basics%20[control].html"
      >link</a
      > to more information.</p
    ></div
  ><div id="protocol-buffer"
  ><h3
    >Protocol-Buffer</h3
    ><p
    >Affinity provides a streaming interface based on Google's protocol-buffers: <a href="./sources/affinity_proto.html"
      >affinity.proto</a
      >. This is one of the interfaces exposed by the <a href="#server"
      >server</a
      >, and also useful in machine-to-machine scenarios via <a href="#service"
      >services</a
      >. Here's a <a href="./interface%20[protobuf].html"
      >link</a
      > to more information.</p
    ></div
  ><div id="client-side-libraries"
  ><h3
    >Client-Side Libraries</h3
    ><p
    >For the traditional client-server scenario, <a href="#pathsql"
      >pathSQL</a
      > still implies a mapping process to translate structured objects on the client side into DDL &amp; DML statements. The <a href="#protocol-buffer"
      >protocol-buffer</a
      > interface provides a more direct means of expressing those structures to Affinity. The client-side libraries further facilitate the use of both interfaces, in the context of their specific programming language. The first release emphasizes <a href="./sources/affinity-client_js.html"
      >javascript</a
      > for node.js. Libraries for <a href="./sources/affinity_py.html"
      >python</a
      > and ruby are also available. Java is soon to be released, and C++ is under development for a future release.</p
    ></div
  ></div
><div id="software-components"
><h1
  >Software Components</h1
  ><p
  >The Affinity package contains the following components: the Affinity <a href="#kernel"
    >kernel</a
    > library, a set of built-in and external <a href="#service"
    >services</a
    >, the database <a href="#server"
    >server</a
    > with its online console and documentation, and some <a href="#client-side-libraries"
    >client-side libraries</a
    >.</p
  ><div id="kernel"
  ><h3
    >Kernel</h3
    ><p
    >The Affinity kernel library is the core component of the Affinity package. Most of the Affinity documentation focuses on various aspects of this component.</p
    ></div
  ><div id="server"
  ><h3
    >Server</h3
    ><p
    >This process is a store access server that embeds the Affinity <a href="#kernel"
      >kernel</a
      >. It understands the HTTP protocol, and accepts messages in <a href="#pathsql"
      >pathSQL</a
      > as well as <a href="#protocol-buffer"
      >protocol-buffer</a
      >. It can return results in json format, or <a href="#protocol-buffer"
      >protocol-buffer</a
      > format. It can also act as as a web server, for increased convenience. For more information, visit this <a href="./server.html"
      >link</a
      >. In the near future, this process will be drastically simplified by substituting its custom implementation with generic <a href="#service"
      >services</a
      >.</p
    ></div
  ><div id="service"
  ><h3
    >Service</h3
    ><p
    >A service is an OS-level compiled plug-in module (dll/so/dylib), loaded dynamically in Affinity and providing additional building blocks for <a href="#communication-pin"
      >communication PINs</a
      >. Those building blocks conform with the <code
      >Afy::IService</code
      > interface defined in <a href="./sources/affinity_h.html"
      >affinity.h</a
      >. Affinity comes with a few built-in services (e.g. Bluetooth Low Energy, NFC, and Zigbee communications, XML and regex parsing, mDNS browsing, a HTTP client and server, etc.). Typically, external services are loaded via a <a href="#loader"
      >loader</a
      > statement.</p
    ></div
  ></div
>
</div>
